
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.Stack;
import java.util.ArrayList;
import java.util.HashMap;
import AdaSemantic.*;
import CodeGeneration.FlatSymbolTable;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\354\000\002\002\004\000\002\006\002\000\002\006" +
    "\003\000\002\002\003\000\002\003\002\000\002\004\002" +
    "\000\002\005\002\000\002\010\003\000\002\010\003\000" +
    "\002\007\003\000\002\007\003\000\002\011\003\000\002" +
    "\013\003\000\002\013\005\000\002\014\003\000\002\014" +
    "\005\000\002\015\003\000\002\015\003\000\002\015\003" +
    "\000\002\015\003\000\002\015\003\000\002\016\010\000" +
    "\002\016\010\000\002\017\002\000\002\017\004\000\002" +
    "\020\010\000\002\020\010\000\002\012\005\000\002\012" +
    "\005\000\002\161\002\000\002\021\011\000\002\021\003" +
    "\000\002\022\002\000\002\022\003\000\002\023\003\000" +
    "\002\024\007\000\002\025\003\000\002\025\003\000\002" +
    "\025\003\000\002\026\004\000\002\026\004\000\002\026" +
    "\004\000\002\026\004\000\002\027\004\000\002\030\005" +
    "\000\002\031\003\000\002\031\003\000\002\032\005\000" +
    "\002\033\002\000\002\033\003\000\002\034\005\000\002" +
    "\035\004\000\002\035\004\000\002\035\003\000\002\162" +
    "\002\000\002\163\002\000\002\036\010\000\002\164\002" +
    "\000\002\037\005\000\002\165\002\000\002\037\005\000" +
    "\002\040\002\000\002\040\004\000\002\041\002\000\002" +
    "\041\003\000\002\166\002\000\002\042\005\000\002\042" +
    "\003\000\002\043\005\000\002\044\003\000\002\044\005" +
    "\000\002\045\006\000\002\045\006\000\002\046\011\000" +
    "\002\047\002\000\002\047\007\000\002\050\003\000\002" +
    "\050\003\000\002\050\004\000\002\050\003\000\002\051" +
    "\003\000\002\051\005\000\002\052\006\000\002\053\003" +
    "\000\002\054\002\000\002\054\004\000\002\055\003\000" +
    "\002\055\003\000\002\055\004\000\002\056\003\000\002" +
    "\056\003\000\002\056\003\000\002\056\003\000\002\057" +
    "\005\000\002\057\005\000\002\057\005\000\002\060\003" +
    "\000\002\060\003\000\002\060\003\000\002\060\003\000" +
    "\002\060\003\000\002\061\005\000\002\061\007\000\002" +
    "\062\005\000\002\062\005\000\002\063\003\000\002\063" +
    "\005\000\002\064\003\000\002\064\003\000\002\064\003" +
    "\000\002\064\003\000\002\064\003\000\002\064\003\000" +
    "\002\065\006\000\002\066\006\000\002\067\005\000\002" +
    "\070\006\000\002\071\006\000\002\072\003\000\002\073" +
    "\003\000\002\073\004\000\002\074\003\000\002\075\003" +
    "\000\002\076\003\000\002\077\003\000\002\100\003\000" +
    "\002\100\003\000\002\100\003\000\002\100\003\000\002" +
    "\100\003\000\002\100\005\000\002\101\003\000\002\101" +
    "\003\000\002\101\003\000\002\101\003\000\002\101\003" +
    "\000\002\101\003\000\002\102\003\000\002\102\003\000" +
    "\002\102\003\000\002\103\003\000\002\103\003\000\002" +
    "\103\003\000\002\103\003\000\002\104\003\000\002\104" +
    "\003\000\002\104\003\000\002\104\003\000\002\105\007" +
    "\000\002\105\005\000\002\106\004\000\002\107\003\000" +
    "\002\107\005\000\002\110\004\000\002\110\004\000\002" +
    "\110\003\000\002\111\002\000\002\111\004\000\002\112" +
    "\003\000\002\112\003\000\002\112\003\000\002\112\003" +
    "\000\002\112\003\000\002\112\003\000\002\112\003\000" +
    "\002\113\003\000\002\113\003\000\002\113\003\000\002" +
    "\114\005\000\002\115\004\000\002\116\006\000\002\167" +
    "\002\000\002\123\010\000\002\117\007\000\002\117\012" +
    "\000\002\120\007\000\002\120\012\000\002\121\002\000" +
    "\002\121\006\000\002\122\003\000\002\170\002\000\002" +
    "\124\010\000\002\124\011\000\002\171\002\000\002\125" +
    "\007\000\002\126\002\000\002\126\007\000\002\126\010" +
    "\000\002\126\005\000\002\172\002\000\002\127\010\000" +
    "\002\173\002\000\002\127\013\000\002\130\002\000\002" +
    "\130\004\000\002\131\006\000\002\132\002\000\002\132" +
    "\003\000\002\133\002\000\002\133\005\000\002\134\004" +
    "\000\002\134\005\000\002\135\005\000\002\136\004\000" +
    "\002\137\005\000\002\140\005\000\002\141\003\000\002" +
    "\141\003\000\002\142\003\000\002\174\002\000\002\143" +
    "\006\000\002\144\002\000\002\144\003\000\002\145\003" +
    "\000\002\145\005\000\002\146\007\000\002\146\007\000" +
    "\002\147\002\000\002\147\003\000\002\147\003\000\002" +
    "\147\004\000\002\175\002\000\002\176\002\000\002\150" +
    "\014\000\002\151\002\000\002\151\003\000\002\152\004" +
    "\000\002\153\005\000\002\154\005\000\002\155\003\000" +
    "\002\156\003\000\002\156\004\000\002\156\003\000\002" +
    "\157\003\000\002\157\003\000\002\160\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u017d\000\006\003\007\061\005\001\002\000\006\002" +
    "\uff17\061\uff17\001\002\000\004\152\030\001\002\000\016" +
    "\003\uffad\016\uffad\061\uffad\075\uffad\102\uffad\152\uffad\001" +
    "\002\000\006\002\uff19\061\uff19\001\002\000\004\002\ufffe" +
    "\001\002\000\006\002\uff1c\061\005\001\002\000\006\002" +
    "\uff18\061\uff18\001\002\000\004\002\017\001\002\000\004" +
    "\124\016\001\002\000\006\002\uff1b\061\uff1b\001\002\000" +
    "\020\002\uff36\003\uff36\016\uff36\061\uff36\075\uff36\102\uff36" +
    "\152\uff36\001\002\000\004\002\001\001\002\000\006\002" +
    "\uff1a\061\uff1a\001\002\000\004\016\334\001\002\000\016" +
    "\003\035\016\uffae\061\005\075\027\102\032\152\030\001" +
    "\002\000\016\003\uffed\016\uffed\061\uffed\075\uffed\102\uffed" +
    "\152\uffed\001\002\000\016\003\uffab\016\uffab\061\uffab\075" +
    "\uffab\102\uffab\152\uffab\001\002\000\016\003\ufff1\016\ufff1" +
    "\061\ufff1\075\ufff1\102\ufff1\152\ufff1\001\002\000\006\121" +
    "\244\123\323\001\002\000\004\152\030\001\002\000\064" +
    "\013\ufff6\024\ufff6\025\ufff6\042\ufff6\043\ufff6\045\ufff6\053" +
    "\ufff6\064\ufff6\101\ufff6\105\ufff6\110\ufff6\112\ufff6\113\ufff6" +
    "\114\ufff6\121\ufff6\122\ufff6\123\ufff6\124\ufff6\133\ufff6\134" +
    "\ufff6\135\ufff6\137\ufff6\141\ufff6\150\ufff6\151\ufff6\001\002" +
    "\000\016\003\uffac\016\uffac\061\uffac\075\uffac\102\uffac\152" +
    "\uffac\001\002\000\004\152\030\001\002\000\016\003\uffee" +
    "\016\uffee\061\uffee\075\uffee\102\uffee\152\uffee\001\002\000" +
    "\016\003\ufff0\016\ufff0\061\ufff0\075\ufff0\102\ufff0\152\ufff0" +
    "\001\002\000\004\124\230\001\002\000\006\121\042\123" +
    "\043\001\002\000\016\003\uffef\016\uffef\061\uffef\075\uffef" +
    "\102\uffef\152\uffef\001\002\000\016\003\uffe2\016\uffe2\061" +
    "\uffe2\075\uffe2\102\uffe2\152\uffe2\001\002\000\016\003\uffaa" +
    "\016\uffaa\061\uffaa\075\uffaa\102\uffaa\152\uffaa\001\002\000" +
    "\004\152\030\001\002\000\016\021\044\145\000\146\000" +
    "\147\000\152\000\156\000\001\002\000\016\137\224\145" +
    "\uffff\146\uffff\147\uffff\152\uffff\156\uffff\001\002\000\014" +
    "\145\051\146\050\147\062\152\030\156\053\001\002\000" +
    "\010\114\uffdc\124\uffdc\137\uffdc\001\002\000\022\024\067" +
    "\025\064\064\170\113\112\114\uffdd\122\111\124\uffdd\137" +
    "\uffdd\001\002\000\014\045\ufffa\064\ufffa\114\ufffa\124\ufffa" +
    "\137\ufffa\001\002\000\010\114\ufff8\124\ufff8\137\ufff8\001" +
    "\002\000\006\124\uffea\137\216\001\002\000\056\013\uff31" +
    "\024\uff31\025\uff31\043\uff31\045\uff31\053\uff31\064\uff31\101" +
    "\uff31\105\uff31\110\uff31\112\uff31\113\uff31\114\uff31\121\uff31" +
    "\122\uff31\124\uff31\133\uff31\134\uff31\135\uff31\137\uff31\150" +
    "\uff31\151\uff31\001\002\000\056\013\uffa7\024\uffa7\025\uffa7" +
    "\043\uffa7\045\uffa7\053\uffa7\064\uffa7\101\uffa7\105\uffa7\110" +
    "\uffa7\112\uffa7\113\uffa7\114\uffa7\121\uffa7\122\uffa7\124\uffa7" +
    "\133\uffa7\134\uffa7\135\uffa7\137\uffa7\150\uffa7\151\uffa7\001" +
    "\002\000\056\013\uffa6\024\uffa6\025\uffa6\043\uffa6\045\uffa6" +
    "\053\uffa6\064\uffa6\101\uffa6\105\uffa6\110\uffa6\112\uffa6\113" +
    "\uffa6\114\uffa6\121\uffa6\122\uffa6\124\uffa6\133\uffa6\134\uffa6" +
    "\135\uffa6\137\uffa6\150\uffa6\151\uffa6\001\002\000\056\013" +
    "\uffa8\024\uffa8\025\uffa8\043\uffa8\045\uffa8\053\uffa8\064\uffa8" +
    "\101\uffa8\105\uffa8\110\uffa8\112\uffa8\113\uffa8\114\uffa8\121" +
    "\uffa8\122\uffa8\124\uffa8\133\uffa8\134\uffa8\135\uffa8\137\uffa8" +
    "\150\uffa8\151\uffa8\001\002\000\010\114\uffdb\124\uffdb\137" +
    "\uffdb\001\002\000\056\013\uffa5\024\uffa5\025\uffa5\043\uffa5" +
    "\045\uffa5\053\uffa5\064\uffa5\101\uffa5\105\uffa5\110\uffa5\112" +
    "\uffa5\113\uffa5\114\uffa5\121\uffa5\122\uffa5\124\uffa5\133\uffa5" +
    "\134\uffa5\135\uffa5\137\uffa5\150\uffa5\151\uffa5\001\002\000" +
    "\012\064\170\114\ufff7\124\ufff7\137\ufff7\001\002\000\016" +
    "\024\067\025\064\064\ufff9\114\ufff9\124\ufff9\137\ufff9\001" +
    "\002\000\010\114\uffd7\124\uffd7\137\uffd7\001\002\000\024" +
    "\047\104\051\107\113\070\152\030\153\103\154\101\155" +
    "\105\156\053\157\071\001\002\000\010\114\uffd4\124\uffd4" +
    "\137\uffd4\001\002\000\010\114\uffd3\124\uffd3\137\uffd3\001" +
    "\002\000\024\047\104\051\107\113\070\152\030\153\103" +
    "\154\101\155\105\156\053\157\071\001\002\000\026\047" +
    "\104\051\107\054\132\113\070\152\030\153\103\154\101" +
    "\155\105\156\053\157\071\001\002\000\040\013\uff9e\045" +
    "\uff9e\053\uff9e\064\uff9e\101\uff9e\110\uff9e\114\uff9e\121\uff9e" +
    "\124\uff9e\133\uff9e\134\uff9e\135\uff9e\137\uff9e\150\uff9e\151" +
    "\uff9e\001\002\000\040\013\uff81\045\uff81\053\uff81\064\uff81" +
    "\101\uff81\110\uff81\114\uff81\121\uff81\124\uff81\133\uff81\134" +
    "\uff81\135\uff81\137\uff81\150\uff81\151\uff81\001\002\000\040" +
    "\013\uff83\045\uff83\053\uff83\064\uff83\101\uff83\110\uff83\114" +
    "\uff83\121\uff83\124\uff83\133\uff83\134\uff83\135\uff83\137\uff83" +
    "\150\uff83\151\uff83\001\002\000\040\013\uff86\045\uff86\053" +
    "\uff86\064\uff86\101\uff86\110\uff86\114\uff86\121\uff86\124\uff86" +
    "\133\uff86\134\uff86\135\uff86\137\uff86\150\uff86\151\uff86\001" +
    "\002\000\040\013\uff87\045\uff87\053\uff87\064\uff87\101\uff87" +
    "\110\uff87\114\uff87\121\uff87\124\uff87\133\uff87\134\uff87\135" +
    "\uff87\137\uff87\150\uff87\151\uff87\001\002\000\012\064\170" +
    "\114\uffd1\124\uffd1\137\uffd1\001\002\000\040\013\uff85\045" +
    "\uff85\053\uff85\064\uff85\101\uff85\110\uff85\114\uff85\121\uff85" +
    "\124\uff85\133\uff85\134\uff85\135\uff85\137\uff85\150\uff85\151" +
    "\uff85\001\002\000\040\013\uff88\045\uff88\053\uff88\064\uff88" +
    "\101\uff88\110\uff88\114\uff88\121\uff88\124\uff88\133\uff88\134" +
    "\uff88\135\uff88\137\uff88\150\uff88\151\uff88\001\002\000\040" +
    "\013\uffa0\045\uffa0\053\uffa0\064\uffa0\101\uffa0\110\uffa0\114" +
    "\uffa0\121\uffa0\124\uffa0\133\uffa0\134\uffa0\135\uffa0\137\uffa0" +
    "\150\uffa0\151\uffa0\001\002\000\040\013\uff84\045\uff84\053" +
    "\uff84\064\uff84\101\uff84\110\uff84\114\uff84\121\uff84\124\uff84" +
    "\133\uff84\134\uff84\135\uff84\137\uff84\150\uff84\151\uff84\001" +
    "\002\000\040\013\uffa1\045\uffa1\053\uffa1\064\uffa1\101\uffa1" +
    "\110\uffa1\114\uffa1\121\uffa1\124\uffa1\133\uffa1\134\uffa1\135" +
    "\uffa1\137\uffa1\150\uffa1\151\uffa1\001\002\000\006\152\030" +
    "\156\053\001\002\000\040\013\uff9f\045\uff9f\053\uff9f\064" +
    "\uff9f\101\uff9f\110\uff9f\114\uff9f\121\uff9f\124\uff9f\133\uff9f" +
    "\134\uff9f\135\uff9f\137\uff9f\150\uff9f\151\uff9f\001\002\000" +
    "\040\013\uff80\045\uff80\053\uff80\064\uff80\101\uff80\110\uff80" +
    "\114\uff80\121\uff80\124\uff80\133\uff80\134\uff80\135\uff80\137" +
    "\uff80\150\uff80\151\uff80\001\002\000\040\013\uff9d\045\uff9d" +
    "\053\uff9d\064\uff9d\101\uff9d\110\uff9d\114\uff9d\121\uff9d\124" +
    "\uff9d\133\uff9d\134\uff9d\135\uff9d\137\uff9d\150\uff9d\151\uff9d" +
    "\001\002\000\046\013\uff82\045\uff82\053\uff82\064\uff82\101" +
    "\uff82\110\uff82\112\113\113\112\114\uff82\121\uff82\122\111" +
    "\124\uff82\133\uff82\134\uff82\135\uff82\137\uff82\150\uff82\151" +
    "\uff82\001\002\000\010\012\203\152\030\156\053\001\002" +
    "\000\004\114\202\001\002\000\004\113\115\001\002\000" +
    "\040\013\uff6c\045\uff6c\053\uff6c\064\uff6c\101\uff6c\110\uff6c" +
    "\114\uff6c\121\uff6c\124\uff6c\133\uff6c\134\uff6c\135\uff6c\137" +
    "\uff6c\150\uff6c\151\uff6c\001\002\000\026\047\104\051\107" +
    "\054\132\113\070\152\030\153\103\154\101\155\105\156" +
    "\053\157\071\001\002\000\014\045\uff92\101\uff92\114\uff92" +
    "\121\uff92\124\uff92\001\002\000\006\114\200\121\177\001" +
    "\002\000\006\133\144\134\174\001\002\000\014\045\uff94" +
    "\101\uff94\114\uff94\121\uff94\124\uff94\001\002\000\006\133" +
    "\uffb2\134\uffb2\001\002\000\036\013\uff82\053\uff82\064\170" +
    "\110\uff82\112\113\113\112\114\uff82\121\uff82\122\111\133" +
    "\uff82\134\uff82\135\uff82\150\uff82\151\uff82\001\002\000\026" +
    "\013\153\045\uff96\053\155\101\uff96\110\156\114\uff96\121" +
    "\uff96\124\uff96\150\154\151\152\001\002\000\006\114\151" +
    "\121\uff98\001\002\000\014\045\uff91\101\uff91\114\uff91\121" +
    "\uff91\124\uff91\001\002\000\006\133\uffb1\134\uffb1\001\002" +
    "\000\014\045\uff95\101\uff95\114\uff95\121\uff95\124\uff95\001" +
    "\002\000\004\121\137\001\002\000\006\133\uffb4\134\uffb4" +
    "\001\002\000\014\045\uff93\101\uff93\114\uff93\121\uff93\124" +
    "\uff93\001\002\000\026\013\uff8b\053\uff8b\110\uff8b\114\uff8b" +
    "\121\uff8b\133\uffb5\134\uffb5\135\135\150\uff8b\151\uff8b\001" +
    "\002\000\024\047\104\051\107\113\070\152\030\153\103" +
    "\154\101\155\105\156\053\157\071\001\002\000\016\045" +
    "\uffd5\114\uffd5\124\uffd5\133\uffd5\134\uffd5\137\uffd5\001\002" +
    "\000\026\047\104\051\107\054\132\113\070\152\030\153" +
    "\103\154\101\155\105\156\053\157\071\001\002\000\006" +
    "\133\144\134\143\001\002\000\006\114\uff9a\121\uff9a\001" +
    "\002\000\006\114\uff98\121\uff98\001\002\000\024\047\104" +
    "\051\107\113\070\152\030\153\103\154\101\155\105\156" +
    "\053\157\071\001\002\000\026\047\104\051\107\054\132" +
    "\113\070\152\030\153\103\154\101\155\105\156\053\157" +
    "\071\001\002\000\006\133\uffb0\134\uffb0\001\002\000\010" +
    "\133\uffb5\134\uffb5\135\135\001\002\000\006\114\uff97\121" +
    "\uff97\001\002\000\026\013\uff8b\045\uff8b\053\uff8b\101\uff8b" +
    "\110\uff8b\114\uff8b\121\uff8b\124\uff8b\150\uff8b\151\uff8b\001" +
    "\002\000\040\013\uff6d\045\uff6d\053\uff6d\064\uff6d\101\uff6d" +
    "\110\uff6d\114\uff6d\121\uff6d\124\uff6d\133\uff6d\134\uff6d\135" +
    "\uff6d\137\uff6d\150\uff6d\151\uff6d\001\002\000\024\047\ufffc" +
    "\051\ufffc\113\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156" +
    "\ufffc\157\ufffc\001\002\000\024\047\ufffc\051\ufffc\113\ufffc" +
    "\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001" +
    "\002\000\024\047\ufffc\051\ufffc\113\ufffc\152\ufffc\153\ufffc" +
    "\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\024\047" +
    "\ufffc\051\ufffc\113\ufffc\152\ufffc\153\ufffc\154\ufffc\155\ufffc" +
    "\156\ufffc\157\ufffc\001\002\000\024\047\104\051\107\113" +
    "\070\152\030\153\103\154\101\155\105\156\053\157\071" +
    "\001\002\000\014\045\uff8e\101\uff8e\114\uff8e\121\uff8e\124" +
    "\uff8e\001\002\000\024\047\104\051\107\113\070\152\030" +
    "\153\103\154\101\155\105\156\053\157\071\001\002\000" +
    "\014\045\uff8f\101\uff8f\114\uff8f\121\uff8f\124\uff8f\001\002" +
    "\000\024\047\104\051\107\113\070\152\030\153\103\154" +
    "\101\155\105\156\053\157\071\001\002\000\014\045\uff8d" +
    "\101\uff8d\114\uff8d\121\uff8d\124\uff8d\001\002\000\024\047" +
    "\104\051\107\113\070\152\030\153\103\154\101\155\105" +
    "\156\053\157\071\001\002\000\014\045\uff90\101\uff90\114" +
    "\uff90\121\uff90\124\uff90\001\002\000\024\047\104\051\107" +
    "\113\070\152\030\153\103\154\101\155\105\156\053\157" +
    "\071\001\002\000\014\045\uff8c\101\uff8c\114\uff8c\121\uff8c" +
    "\124\uff8c\001\002\000\024\047\104\051\107\113\070\152" +
    "\030\153\103\154\101\155\105\156\053\157\071\001\002" +
    "\000\006\133\uffb3\134\uffb3\001\002\000\016\045\uffd6\114" +
    "\uffd6\124\uffd6\133\uffd6\134\uffd6\137\uffd6\001\002\000\004" +
    "\135\135\001\002\000\024\047\104\051\107\113\070\152" +
    "\030\153\103\154\101\155\105\156\053\157\071\001\002" +
    "\000\006\114\176\121\uff97\001\002\000\040\013\uff9b\045" +
    "\uff9b\053\uff9b\064\uff9b\101\uff9b\110\uff9b\114\uff9b\121\uff9b" +
    "\124\uff9b\133\uff9b\134\uff9b\135\uff9b\137\uff9b\150\uff9b\151" +
    "\uff9b\001\002\000\026\047\104\051\107\054\132\113\070" +
    "\152\030\153\103\154\101\155\105\156\053\157\071\001" +
    "\002\000\040\013\uff9c\045\uff9c\053\uff9c\064\uff9c\101\uff9c" +
    "\110\uff9c\114\uff9c\121\uff9c\124\uff9c\133\uff9c\134\uff9c\135" +
    "\uff9c\137\uff9c\150\uff9c\151\uff9c\001\002\000\006\114\uff99" +
    "\121\uff99\001\002\000\056\013\uff1e\024\uff1e\025\uff1e\043" +
    "\uff1e\045\uff1e\053\uff1e\064\uff1e\101\uff1e\105\uff1e\110\uff1e" +
    "\112\uff1e\113\uff1e\114\uff1e\121\uff1e\122\uff1e\124\uff1e\133" +
    "\uff1e\134\uff1e\135\uff1e\137\uff1e\150\uff1e\151\uff1e\001\002" +
    "\000\056\013\uffa3\024\uffa3\025\uffa3\043\uffa3\045\uffa3\053" +
    "\uffa3\064\uffa3\101\uffa3\105\uffa3\110\uffa3\112\uffa3\113\uffa3" +
    "\114\uffa3\121\uffa3\122\uffa3\124\uffa3\133\uffa3\134\uffa3\135" +
    "\uffa3\137\uffa3\150\uffa3\151\uffa3\001\002\000\056\013\uffa4" +
    "\024\uffa4\025\uffa4\043\uffa4\045\uffa4\053\uffa4\064\uffa4\101" +
    "\uffa4\105\uffa4\110\uffa4\112\uffa4\113\uffa4\114\uffa4\121\uffa4" +
    "\122\uffa4\124\uffa4\133\uffa4\134\uffa4\135\uffa4\137\uffa4\150" +
    "\uffa4\151\uffa4\001\002\000\056\013\uffa2\024\uffa2\025\uffa2" +
    "\043\uffa2\045\uffa2\053\uffa2\064\uffa2\101\uffa2\105\uffa2\110" +
    "\uffa2\112\uffa2\113\uffa2\114\uffa2\121\uffa2\122\uffa2\124\uffa2" +
    "\133\uffa2\134\uffa2\135\uffa2\137\uffa2\150\uffa2\151\uffa2\001" +
    "\002\000\044\013\uff6b\045\uff6b\053\uff6b\064\uff6b\101\uff6b" +
    "\110\uff6b\113\112\114\uff6b\121\uff6b\122\111\124\uff6b\133" +
    "\uff6b\134\uff6b\135\uff6b\137\uff6b\150\uff6b\151\uff6b\001\002" +
    "\000\010\114\uffcf\124\uffcf\137\uffcf\001\002\000\012\045" +
    "\uffd0\114\uffd0\124\uffd0\137\uffd0\001\002\000\006\114\212" +
    "\121\uff98\001\002\000\040\013\uff7f\045\uff7f\053\uff7f\064" +
    "\uff7f\101\uff7f\110\uff7f\114\uff7f\121\uff7f\124\uff7f\133\uff7f" +
    "\134\uff7f\135\uff7f\137\uff7f\150\uff7f\151\uff7f\001\002\000" +
    "\012\064\170\114\uffd1\124\uffd1\137\uffd1\001\002\000\010" +
    "\114\uffd2\124\uffd2\137\uffd2\001\002\000\010\114\uffd8\124" +
    "\uffd8\137\uffd8\001\002\000\024\047\104\051\107\113\070" +
    "\152\030\153\103\154\101\155\105\156\053\157\071\001" +
    "\002\000\004\124\220\001\002\000\016\003\uffeb\016\uffeb" +
    "\061\uffeb\075\uffeb\102\uffeb\152\uffeb\001\002\000\006\114" +
    "\uffe9\124\uffe9\001\002\000\010\114\uffda\124\uffda\137\uffda" +
    "\001\002\000\010\114\uffd9\124\uffd9\137\uffd9\001\002\000" +
    "\024\047\104\051\107\113\070\152\030\153\103\154\101" +
    "\155\105\156\053\157\071\001\002\000\004\124\226\001" +
    "\002\000\016\003\uffe7\016\uffe7\061\uffe7\075\uffe7\102\uffe7" +
    "\152\uffe7\001\002\000\006\121\uffe5\123\uffe5\001\002\000" +
    "\016\003\uffa9\016\uffa9\061\uffa9\075\uffa9\102\uffa9\152\uffa9" +
    "\001\002\000\010\043\uffe1\113\233\124\uffe1\001\002\000" +
    "\006\043\255\124\254\001\002\000\004\152\030\001\002" +
    "\000\006\043\uffe0\124\uffe0\001\002\000\006\114\uffbc\124" +
    "\uffbc\001\002\000\006\114\251\124\252\001\002\000\006" +
    "\121\244\123\245\001\002\000\006\121\042\123\241\001" +
    "\002\000\014\145\051\146\050\147\062\152\030\156\053" +
    "\001\002\000\010\114\uffea\124\uffea\137\216\001\002\000" +
    "\006\114\uffb9\124\uffb9\001\002\000\004\152\030\001\002" +
    "\000\014\145\051\146\050\147\062\152\030\156\053\001" +
    "\002\000\010\114\uffea\124\uffea\137\216\001\002\000\006" +
    "\114\uffba\124\uffba\001\002\000\006\121\uffe6\123\uffe6\001" +
    "\002\000\006\043\uffbd\124\uffbd\001\002\000\004\152\030" +
    "\001\002\000\006\114\uffbb\124\uffbb\001\002\000\016\003" +
    "\uffaf\016\uffaf\061\uffaf\075\uffaf\102\uffaf\152\uffaf\001\002" +
    "\000\004\065\uffe4\001\002\000\004\065\257\001\002\000" +
    "\014\003\uffcb\020\uffcb\031\uffcb\051\uffcb\152\uffcb\001\002" +
    "\000\004\124\262\001\002\000\004\124\uffdf\001\002\000" +
    "\016\003\uffe3\016\uffe3\061\uffe3\075\uffe3\102\uffe3\152\uffe3" +
    "\001\002\000\014\003\uffc4\020\uffc4\031\uffc4\051\266\152" +
    "\uffc4\001\002\000\014\003\275\020\uffc8\031\uffc8\105\uffc8" +
    "\152\030\001\002\000\004\031\uffca\001\002\000\004\124" +
    "\uffc6\001\002\000\004\124\270\001\002\000\006\031\uffc5" +
    "\105\uffc5\001\002\000\004\031\272\001\002\000\004\065" +
    "\273\001\002\000\004\124\uffc9\001\002\000\010\020\304" +
    "\031\uffc2\105\uffc2\001\002\000\014\003\uffbe\020\uffbe\031" +
    "\uffbe\105\uffbe\152\uffbe\001\002\000\004\124\uffc0\001\002" +
    "\000\014\003\uffc3\020\uffc3\031\uffc3\105\uffc3\152\uffc3\001" +
    "\002\000\004\124\301\001\002\000\014\003\uffbf\020\uffbf" +
    "\031\uffbf\105\uffbf\152\uffbf\001\002\000\006\031\uffc1\105" +
    "\uffc1\001\002\000\006\031\uffc7\105\uffc7\001\002\000\006" +
    "\152\030\156\053\001\002\000\010\043\306\113\112\122" +
    "\111\001\002\000\006\031\uffb7\105\uffb7\001\002\000\006" +
    "\031\311\105\310\001\002\000\026\047\104\051\107\054" +
    "\132\113\070\152\030\153\103\154\101\155\105\156\053" +
    "\157\071\001\002\000\004\020\312\001\002\000\004\124" +
    "\313\001\002\000\006\031\uffb8\105\uffb8\001\002\000\006" +
    "\133\144\134\315\001\002\000\016\003\uffc4\020\uffc4\031" +
    "\uffc4\051\266\105\uffc4\152\uffc4\001\002\000\006\031\uffb6" +
    "\105\uffb6\001\002\000\004\043\320\001\002\000\014\145" +
    "\051\146\050\147\062\152\030\156\053\001\002\000\004" +
    "\124\322\001\002\000\016\003\uffde\016\uffde\061\uffde\075" +
    "\uffde\102\uffde\152\uffde\001\002\000\016\021\324\145\000" +
    "\146\000\147\000\152\000\156\000\001\002\000\016\137" +
    "\331\145\uffff\146\uffff\147\uffff\152\uffff\156\uffff\001\002" +
    "\000\014\145\051\146\050\147\062\152\030\156\053\001" +
    "\002\000\006\124\uffea\137\216\001\002\000\004\124\330" +
    "\001\002\000\016\003\uffec\016\uffec\061\uffec\075\uffec\102" +
    "\uffec\152\uffec\001\002\000\024\047\104\051\107\113\070" +
    "\152\030\153\103\154\101\155\105\156\053\157\071\001" +
    "\002\000\004\124\333\001\002\000\016\003\uffe8\016\uffe8" +
    "\061\uffe8\075\uffe8\102\uffe8\152\uffe8\001\002\000\036\003" +
    "\uff24\016\uff24\022\uff24\034\uff24\035\uff24\040\uff24\041\uff24" +
    "\045\uff24\051\uff24\071\uff24\106\uff24\140\uff24\152\uff24\156" +
    "\uff24\001\002\000\036\003\337\016\uff65\022\uff65\034\uff65" +
    "\035\uff65\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65\106" +
    "\uff65\140\uff65\152\uff65\156\uff65\001\002\000\040\003\ufffc" +
    "\016\ufffc\022\ufffc\031\u0160\034\ufffc\035\ufffc\040\ufffc\041" +
    "\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc" +
    "\156\ufffc\001\002\000\044\003\uff66\016\uff66\022\uff66\027" +
    "\uff66\030\uff66\031\uff66\034\uff66\035\uff66\040\uff66\041\uff66" +
    "\045\uff66\051\uff66\071\uff66\106\uff66\140\uff66\152\uff66\156" +
    "\uff66\001\002\000\034\016\uff40\022\372\034\342\035\370" +
    "\040\346\041\353\045\uff48\051\371\071\351\106\347\140" +
    "\365\152\030\156\053\001\002\000\044\003\uff6a\016\uff6a" +
    "\022\uff6a\027\uff6a\030\uff6a\031\uff6a\034\uff6a\035\uff6a\040" +
    "\uff6a\041\uff6a\045\uff6a\051\uff6a\071\uff6a\106\uff6a\140\uff6a" +
    "\152\uff6a\156\uff6a\001\002\000\012\105\uff3d\124\uff3d\152" +
    "\030\156\053\001\002\000\044\003\uff5d\016\uff5d\022\uff5d" +
    "\027\uff5d\030\uff5d\031\uff5d\034\uff5d\035\uff5d\040\uff5d\041" +
    "\uff5d\045\uff5d\051\uff5d\071\uff5d\106\uff5d\140\uff5d\152\uff5d" +
    "\156\uff5d\001\002\000\016\112\uffa8\113\uffa8\122\uffa8\123" +
    "\u014c\124\uffa8\137\uffa8\001\002\000\044\003\uff5c\016\uff5c" +
    "\022\uff5c\027\uff5c\030\uff5c\031\uff5c\034\uff5c\035\uff5c\040" +
    "\uff5c\041\uff5c\045\uff5c\051\uff5c\071\uff5c\106\uff5c\140\uff5c" +
    "\152\uff5c\156\uff5c\001\002\000\006\152\030\156\053\001" +
    "\002\000\024\047\ufffc\051\ufffc\113\ufffc\152\ufffc\153\ufffc" +
    "\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\044\003" +
    "\uff63\016\uff63\022\uff63\027\uff63\030\uff63\031\uff63\034\uff63" +
    "\035\uff63\040\uff63\041\uff63\045\uff63\051\uff63\071\uff63\106" +
    "\uff63\140\uff63\152\uff63\156\uff63\001\002\000\026\047\104" +
    "\051\107\113\070\124\u0145\152\030\153\103\154\101\155" +
    "\105\156\053\157\071\001\002\000\044\003\uff62\016\uff62" +
    "\022\uff62\027\uff62\030\uff62\031\uff62\034\uff62\035\uff62\040" +
    "\uff62\041\uff62\045\uff62\051\uff62\071\uff62\106\uff62\140\uff62" +
    "\152\uff62\156\uff62\001\002\000\024\047\104\051\107\113" +
    "\070\152\030\153\103\154\101\155\105\156\053\157\071" +
    "\001\002\000\044\003\uff5a\016\uff5a\022\uff5a\027\uff5a\030" +
    "\uff5a\031\uff5a\034\uff5a\035\uff5a\040\uff5a\041\uff5a\045\uff5a" +
    "\051\uff5a\071\uff5a\106\uff5a\140\uff5a\152\uff5a\156\uff5a\001" +
    "\002\000\034\016\uff64\022\uff64\034\uff64\035\uff64\040\uff64" +
    "\041\uff64\045\uff64\051\uff64\071\uff64\106\uff64\140\uff64\152" +
    "\uff64\156\uff64\001\002\000\044\003\uff67\016\uff67\022\uff67" +
    "\027\uff67\030\uff67\031\uff67\034\uff67\035\uff67\040\uff67\041" +
    "\uff67\045\uff67\051\uff67\071\uff67\106\uff67\140\uff67\152\uff67" +
    "\156\uff67\001\002\000\044\003\uff5b\016\uff5b\022\uff5b\027" +
    "\uff5b\030\uff5b\031\uff5b\034\uff5b\035\uff5b\040\uff5b\041\uff5b" +
    "\045\uff5b\051\uff5b\071\uff5b\106\uff5b\140\uff5b\152\uff5b\156" +
    "\uff5b\001\002\000\044\003\uff5e\016\uff5e\022\uff5e\027\uff5e" +
    "\030\uff5e\031\uff5e\034\uff5e\035\uff5e\040\uff5e\041\uff5e\045" +
    "\uff5e\051\uff5e\071\uff5e\106\uff5e\140\uff5e\152\uff5e\156\uff5e" +
    "\001\002\000\004\016\u013b\001\002\000\004\045\ufffc\001" +
    "\002\000\044\003\uff5f\016\uff5f\022\uff5f\027\uff5f\030\uff5f" +
    "\031\uff5f\034\uff5f\035\uff5f\040\uff5f\041\uff5f\045\uff5f\051" +
    "\uff5f\071\uff5f\106\uff5f\140\uff5f\152\uff5f\156\uff5f\001\002" +
    "\000\010\027\ufffb\030\ufffb\031\uff50\001\002\000\004\152" +
    "\030\001\002\000\044\003\uff61\016\uff61\022\uff61\027\uff61" +
    "\030\uff61\031\uff61\034\uff61\035\uff61\040\uff61\041\uff61\045" +
    "\uff61\051\uff61\071\uff61\106\uff61\140\uff61\152\uff61\156\uff61" +
    "\001\002\000\004\124\u0111\001\002\000\004\152\030\001" +
    "\002\000\004\124\u0103\001\002\000\016\003\uffad\016\uffad" +
    "\061\uffad\075\uffad\102\uffad\152\uffad\001\002\000\044\003" +
    "\uff68\016\uff68\022\uff68\027\uff68\030\uff68\031\uff68\034\uff68" +
    "\035\uff68\040\uff68\041\uff68\045\uff68\051\uff68\071\uff68\106" +
    "\uff68\140\uff68\152\uff68\156\uff68\001\002\000\044\003\uff60" +
    "\016\uff60\022\uff60\027\uff60\030\uff60\031\uff60\034\uff60\035" +
    "\uff60\040\uff60\041\uff60\045\uff60\051\uff60\071\uff60\106\uff60" +
    "\140\uff60\152\uff60\156\uff60\001\002\000\014\112\113\113" +
    "\112\122\111\124\377\137\376\001\002\000\024\047\104" +
    "\051\107\113\070\152\030\153\103\154\101\155\105\156" +
    "\053\157\071\001\002\000\044\003\uff1f\016\uff1f\022\uff1f" +
    "\027\uff1f\030\uff1f\031\uff1f\034\uff1f\035\uff1f\040\uff1f\041" +
    "\uff1f\045\uff1f\051\uff1f\071\uff1f\106\uff1f\140\uff1f\152\uff1f" +
    "\156\uff1f\001\002\000\004\124\u0101\001\002\000\044\003" +
    "\uff57\016\uff57\022\uff57\027\uff57\030\uff57\031\uff57\034\uff57" +
    "\035\uff57\040\uff57\041\uff57\045\uff57\051\uff57\071\uff57\106" +
    "\uff57\140\uff57\152\uff57\156\uff57\001\002\000\004\016\uff3f" +
    "\001\002\000\044\003\uff58\016\uff58\022\uff58\027\uff58\030" +
    "\uff58\031\uff58\034\uff58\035\uff58\040\uff58\041\uff58\045\uff58" +
    "\051\uff58\071\uff58\106\uff58\140\uff58\152\uff58\156\uff58\001" +
    "\002\000\004\042\u0105\001\002\000\032\047\104\051\107" +
    "\072\u010a\113\070\146\050\147\u0106\152\030\153\103\154" +
    "\101\155\105\156\053\157\071\001\002\000\006\045\ufff9" +
    "\064\ufff9\001\002\000\004\045\uffcc\001\002\000\004\045" +
    "\ufffc\001\002\000\006\045\uffd1\064\170\001\002\000\030" +
    "\047\104\051\107\113\070\146\050\147\u0106\152\030\153" +
    "\103\154\101\155\105\156\053\157\071\001\002\000\016" +
    "\045\uffd1\064\170\112\113\113\112\122\111\135\uff82\001" +
    "\002\000\004\045\uffce\001\002\000\004\045\ufffc\001\002" +
    "\000\004\045\uff46\001\002\000\004\045\uffcd\001\002\000" +
    "\004\045\uff47\001\002\000\044\003\uff16\016\uff16\022\uff16" +
    "\027\uff16\030\uff16\031\uff16\034\uff16\035\uff16\040\uff16\041" +
    "\uff16\045\uff16\051\uff16\071\uff16\106\uff16\140\uff16\152\uff16" +
    "\156\uff16\001\002\000\004\141\u0113\001\002\000\034\016" +
    "\uff59\022\uff59\034\uff59\035\uff59\040\uff59\041\uff59\045\uff59" +
    "\051\uff59\071\uff59\106\uff59\140\uff59\152\uff59\156\uff59\001" +
    "\002\000\004\031\u012e\001\002\000\006\027\u0117\030\ufffc" +
    "\001\002\000\004\030\u011d\001\002\000\036\003\ufffc\016" +
    "\ufffc\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc" +
    "\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc\001" +
    "\002\000\036\003\337\016\uff65\022\uff65\034\uff65\035\uff65" +
    "\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65\106\uff65\140" +
    "\uff65\152\uff65\156\uff65\001\002\000\040\003\ufffc\016\ufffc" +
    "\022\ufffc\031\uff4f\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045" +
    "\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc" +
    "\001\002\000\036\003\337\016\uff65\022\uff65\034\uff65\035" +
    "\uff65\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65\106\uff65" +
    "\140\uff65\152\uff65\156\uff65\001\002\000\044\003\uff69\016" +
    "\uff69\022\uff69\027\uff69\030\uff69\031\uff69\034\uff69\035\uff69" +
    "\040\uff69\041\uff69\045\uff69\051\uff69\071\uff69\106\uff69\140" +
    "\uff69\152\uff69\156\uff69\001\002\000\010\027\ufffb\030\ufffb" +
    "\031\uff50\001\002\000\024\047\104\051\107\113\070\152" +
    "\030\153\103\154\101\155\105\156\053\157\071\001\002" +
    "\000\010\045\uff4e\101\uff4e\124\uff4e\001\002\000\004\101" +
    "\u0120\001\002\000\036\003\ufffc\016\ufffc\022\ufffc\034\ufffc" +
    "\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106" +
    "\ufffc\140\ufffc\152\ufffc\156\ufffc\001\002\000\036\003\337" +
    "\016\uff65\022\uff65\034\uff65\035\uff65\040\uff65\041\uff65\045" +
    "\uff65\051\uff65\071\uff65\106\uff65\140\uff65\152\uff65\156\uff65" +
    "\001\002\000\044\003\ufffc\016\ufffc\022\ufffc\027\uff52\030" +
    "\uff52\031\uff52\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc" +
    "\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc\001" +
    "\002\000\004\031\u012b\001\002\000\006\027\u0117\030\u0125" +
    "\001\002\000\024\047\ufffc\051\ufffc\113\ufffc\152\ufffc\153" +
    "\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001\002\000\024" +
    "\047\104\051\107\113\070\152\030\153\103\154\101\155" +
    "\105\156\053\157\071\001\002\000\004\101\u0128\001\002" +
    "\000\036\003\ufffc\016\ufffc\022\ufffc\034\ufffc\035\ufffc\040" +
    "\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc" +
    "\152\ufffc\156\ufffc\001\002\000\036\003\337\016\uff65\022" +
    "\uff65\034\uff65\035\uff65\040\uff65\041\uff65\045\uff65\051\uff65" +
    "\071\uff65\106\uff65\140\uff65\152\uff65\156\uff65\001\002\000" +
    "\044\003\ufffc\016\ufffc\022\ufffc\027\uff51\030\uff51\031\uff51" +
    "\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071" +
    "\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc\001\002\000\004" +
    "\041\u012c\001\002\000\004\124\u012d\001\002\000\044\003" +
    "\uff53\016\uff53\022\uff53\027\uff53\030\uff53\031\uff53\034\uff53" +
    "\035\uff53\040\uff53\041\uff53\045\uff53\051\uff53\071\uff53\106" +
    "\uff53\140\uff53\152\uff53\156\uff53\001\002\000\004\041\u012f" +
    "\001\002\000\004\124\u0130\001\002\000\044\003\uff54\016" +
    "\uff54\022\uff54\027\uff54\030\uff54\031\uff54\034\uff54\035\uff54" +
    "\040\uff54\041\uff54\045\uff54\051\uff54\071\uff54\106\uff54\140" +
    "\uff54\152\uff54\156\uff54\001\002\000\004\045\u0133\001\002" +
    "\000\004\124\u0138\001\002\000\036\003\uff4a\016\uff4a\022" +
    "\uff4a\034\uff4a\035\uff4a\040\uff4a\041\uff4a\045\uff4a\051\uff4a" +
    "\071\uff4a\106\uff4a\140\uff4a\152\uff4a\156\uff4a\001\002\000" +
    "\036\003\337\016\uff65\022\uff65\034\uff65\035\uff65\040\uff65" +
    "\041\uff65\045\uff65\051\uff65\071\uff65\106\uff65\140\uff65\152" +
    "\uff65\156\uff65\001\002\000\040\003\ufffc\016\ufffc\022\ufffc" +
    "\031\u0136\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045\ufffc\051" +
    "\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc\001\002" +
    "\000\004\045\u0137\001\002\000\006\124\uff49\152\uff49\001" +
    "\002\000\044\003\uff4d\016\uff4d\022\uff4d\027\uff4d\030\uff4d" +
    "\031\uff4d\034\uff4d\035\uff4d\040\uff4d\041\uff4d\045\uff4d\051" +
    "\uff4d\071\uff4d\106\uff4d\140\uff4d\152\uff4d\156\uff4d\001\002" +
    "\000\044\003\ufffd\016\ufffd\022\ufffd\027\ufffd\030\ufffd\031" +
    "\ufffd\034\ufffd\035\ufffd\040\ufffd\041\ufffd\045\ufffd\051\ufffd" +
    "\071\ufffd\106\ufffd\140\ufffd\152\ufffd\156\ufffd\001\002\000" +
    "\044\003\uff4c\016\uff4c\022\uff4c\027\uff4c\030\uff4c\031\uff4c" +
    "\034\uff4c\035\uff4c\040\uff4c\041\uff4c\045\uff4c\051\uff4c\071" +
    "\uff4c\106\uff4c\140\uff4c\152\uff4c\156\uff4c\001\002\000\036" +
    "\003\uff44\016\uff44\022\uff44\034\uff44\035\uff44\040\uff44\041" +
    "\uff44\045\uff44\051\uff44\071\uff44\106\uff44\140\uff44\152\uff44" +
    "\156\uff44\001\002\000\036\003\337\016\uff65\022\uff65\034" +
    "\uff65\035\uff65\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65" +
    "\106\uff65\140\uff65\152\uff65\156\uff65\001\002\000\040\003" +
    "\ufffc\016\ufffc\022\ufffc\031\u013e\034\ufffc\035\ufffc\040\ufffc" +
    "\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152" +
    "\ufffc\156\ufffc\001\002\000\004\124\u013f\001\002\000\044" +
    "\003\uff43\016\uff43\022\uff43\027\uff43\030\uff43\031\uff43\034" +
    "\uff43\035\uff43\040\uff43\041\uff43\045\uff43\051\uff43\071\uff43" +
    "\106\uff43\140\uff43\152\uff43\156\uff43\001\002\000\004\101" +
    "\u0141\001\002\000\036\003\uff56\016\uff56\022\uff56\034\uff56" +
    "\035\uff56\040\uff56\041\uff56\045\uff56\051\uff56\071\uff56\106" +
    "\uff56\140\uff56\152\uff56\156\uff56\001\002\000\036\003\ufffc" +
    "\016\ufffc\022\ufffc\034\ufffc\035\ufffc\040\ufffc\041\ufffc\045" +
    "\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156\ufffc" +
    "\001\002\000\036\003\337\016\uff65\022\uff65\034\uff65\035" +
    "\uff65\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65\106\uff65" +
    "\140\uff65\152\uff65\156\uff65\001\002\000\044\003\ufffc\016" +
    "\ufffc\022\ufffc\027\uff55\030\uff55\031\uff55\034\ufffc\035\ufffc" +
    "\040\ufffc\041\ufffc\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140" +
    "\ufffc\152\ufffc\156\ufffc\001\002\000\044\003\uff39\016\uff39" +
    "\022\uff39\027\uff39\030\uff39\031\uff39\034\uff39\035\uff39\040" +
    "\uff39\041\uff39\045\uff39\051\uff39\071\uff39\106\uff39\140\uff39" +
    "\152\uff39\156\uff39\001\002\000\004\124\u0147\001\002\000" +
    "\044\003\uff38\016\uff38\022\uff38\027\uff38\030\uff38\031\uff38" +
    "\034\uff38\035\uff38\040\uff38\041\uff38\045\uff38\051\uff38\071" +
    "\uff38\106\uff38\140\uff38\152\uff38\156\uff38\001\002\000\024" +
    "\047\104\051\107\113\070\152\030\153\103\154\101\155" +
    "\105\156\053\157\071\001\002\000\004\045\uff45\001\002" +
    "\000\010\113\112\122\111\124\u014b\001\002\000\044\003" +
    "\uff37\016\uff37\022\uff37\027\uff37\030\uff37\031\uff37\034\uff37" +
    "\035\uff37\040\uff37\041\uff37\045\uff37\051\uff37\071\uff37\106" +
    "\uff37\140\uff37\152\uff37\156\uff37\001\002\000\014\016\uff40" +
    "\022\372\035\370\045\uff48\106\347\001\002\000\004\045" +
    "\ufffc\001\002\000\004\016\u014f\001\002\000\036\003\uff42" +
    "\016\uff42\022\uff42\034\uff42\035\uff42\040\uff42\041\uff42\045" +
    "\uff42\051\uff42\071\uff42\106\uff42\140\uff42\152\uff42\156\uff42" +
    "\001\002\000\036\003\337\016\uff65\022\uff65\034\uff65\035" +
    "\uff65\040\uff65\041\uff65\045\uff65\051\uff65\071\uff65\106\uff65" +
    "\140\uff65\152\uff65\156\uff65\001\002\000\040\003\ufffc\016" +
    "\ufffc\022\ufffc\031\u0152\034\ufffc\035\ufffc\040\ufffc\041\ufffc" +
    "\045\ufffc\051\ufffc\071\ufffc\106\ufffc\140\ufffc\152\ufffc\156" +
    "\ufffc\001\002\000\004\152\030\001\002\000\004\124\u0154" +
    "\001\002\000\044\003\uff41\016\uff41\022\uff41\027\uff41\030" +
    "\uff41\031\uff41\034\uff41\035\uff41\040\uff41\041\uff41\045\uff41" +
    "\051\uff41\071\uff41\106\uff41\140\uff41\152\uff41\156\uff41\001" +
    "\002\000\004\045\u0133\001\002\000\004\152\030\001\002" +
    "\000\004\124\u0158\001\002\000\044\003\uff4b\016\uff4b\022" +
    "\uff4b\027\uff4b\030\uff4b\031\uff4b\034\uff4b\035\uff4b\040\uff4b" +
    "\041\uff4b\045\uff4b\051\uff4b\071\uff4b\106\uff4b\140\uff4b\152" +
    "\uff4b\156\uff4b\001\002\000\006\105\u015c\124\uff3b\001\002" +
    "\000\012\105\uff3c\113\112\122\111\124\uff3c\001\002\000" +
    "\004\124\u015f\001\002\000\024\047\ufffc\051\ufffc\113\ufffc" +
    "\152\ufffc\153\ufffc\154\ufffc\155\ufffc\156\ufffc\157\ufffc\001" +
    "\002\000\024\047\104\051\107\113\070\152\030\153\103" +
    "\154\101\155\105\156\053\157\071\001\002\000\004\124" +
    "\uff3a\001\002\000\044\003\uff3e\016\uff3e\022\uff3e\027\uff3e" +
    "\030\uff3e\031\uff3e\034\uff3e\035\uff3e\040\uff3e\041\uff3e\045" +
    "\uff3e\051\uff3e\071\uff3e\106\uff3e\140\uff3e\152\uff3e\156\uff3e" +
    "\001\002\000\010\124\uff21\152\030\156\053\001\002\000" +
    "\004\124\uff20\001\002\000\004\124\uff33\001\002\000\004" +
    "\124\uff32\001\002\000\004\124\u0165\001\002\000\020\002" +
    "\uff23\003\uff23\016\uff23\061\uff23\075\uff23\102\uff23\152\uff23" +
    "\001\002\000\020\002\ufffd\003\ufffd\016\ufffd\061\ufffd\075" +
    "\ufffd\102\ufffd\152\ufffd\001\002\000\020\002\uff22\003\uff22" +
    "\016\uff22\061\uff22\075\uff22\102\uff22\152\uff22\001\002\000" +
    "\010\043\u016a\113\u016c\124\uff2e\001\002\000\004\124\uff2d" +
    "\001\002\000\016\003\uff34\016\uff34\061\uff34\075\uff34\102" +
    "\uff34\152\uff34\001\002\000\004\124\uff35\001\002\000\004" +
    "\152\030\001\002\000\006\114\uff30\124\u017c\001\002\000" +
    "\006\121\244\123\u0178\001\002\000\006\114\uff2c\124\uff2c" +
    "\001\002\000\006\121\042\123\u0171\001\002\000\020\042" +
    "\u0173\055\u0172\145\uff28\146\uff28\147\uff28\152\uff28\156\uff28" +
    "\001\002\000\014\145\uff26\146\uff26\147\uff26\152\uff26\156" +
    "\uff26\001\002\000\016\055\u0177\145\uff27\146\uff27\147\uff27" +
    "\152\uff27\156\uff27\001\002\000\014\145\051\146\050\147" +
    "\062\152\030\156\053\001\002\000\010\114\uffea\124\uffea" +
    "\137\216\001\002\000\006\114\uff29\124\uff29\001\002\000" +
    "\014\145\uff25\146\uff25\147\uff25\152\uff25\156\uff25\001\002" +
    "\000\020\042\u0173\055\u0172\145\uff28\146\uff28\147\uff28\152" +
    "\uff28\156\uff28\001\002\000\014\145\051\146\050\147\062" +
    "\152\030\156\053\001\002\000\010\114\uffea\124\uffea\137" +
    "\216\001\002\000\006\114\uff2a\124\uff2a\001\002\000\004" +
    "\152\030\001\002\000\004\114\u017e\001\002\000\004\124" +
    "\uff2f\001\002\000\006\114\uff2b\124\uff2b\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u017d\000\022\002\012\136\011\137\013\140\005\150" +
    "\003\155\007\156\010\157\014\001\001\000\002\001\001" +
    "\000\004\011\u0167\001\001\000\006\053\020\054\021\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\136\011" +
    "\137\013\140\005\150\003\157\017\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\034\011\025\012\035\015\023\016\024" +
    "\020\022\021\033\024\032\052\037\055\030\136\036\137" +
    "\013\140\005\150\040\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\011" +
    "\316\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\230\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\011\226\001\001\000" +
    "\004\006\044\001\001\000\002\001\001\000\024\007\056" +
    "\010\060\011\055\025\051\026\045\056\046\057\053\142" +
    "\057\153\054\001\001\000\002\001\001\000\012\027\221" +
    "\031\222\032\064\034\065\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\017\216\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\027\214\001\001" +
    "\000\010\031\062\032\064\034\065\001\001\000\002\001" +
    "\001\000\036\011\055\056\107\057\053\060\101\061\072" +
    "\074\212\075\077\076\074\077\073\100\076\105\105\106" +
    "\071\142\057\153\054\001\001\000\002\001\001\000\002" +
    "\001\001\000\036\011\055\056\107\057\053\060\101\061" +
    "\072\074\075\075\077\076\074\077\073\100\076\105\105" +
    "\106\071\142\057\153\054\001\001\000\066\011\055\030" +
    "\121\050\126\051\117\056\122\057\053\060\101\061\072" +
    "\062\116\063\130\064\210\065\127\066\120\067\132\070" +
    "\115\071\125\072\123\074\133\075\077\076\074\077\073" +
    "\100\076\105\105\106\071\142\057\153\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\027\207\033\206\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\011\055\056" +
    "\205\057\053\142\057\153\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\006\011\203\142\204\001\001\000\002\001\001\000\004" +
    "\061\113\001\001\000\002\001\001\000\066\011\055\030" +
    "\121\050\126\051\117\056\122\057\053\060\101\061\072" +
    "\062\116\063\130\064\124\065\127\066\120\067\132\070" +
    "\115\071\125\072\123\074\133\075\077\076\074\077\073" +
    "\100\076\105\105\106\071\142\057\153\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\027\170\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\036\011\055" +
    "\056\107\057\053\060\101\061\072\074\135\075\077\076" +
    "\074\077\073\100\076\105\105\106\071\142\057\153\054" +
    "\001\001\000\002\001\001\000\064\011\055\030\121\050" +
    "\126\051\137\056\122\057\053\060\101\061\072\063\140" +
    "\064\141\065\127\066\120\067\132\070\115\071\125\072" +
    "\123\074\133\075\077\076\074\077\073\100\076\105\105" +
    "\106\071\142\057\153\054\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\054\011\055\056\107" +
    "\057\053\060\101\061\072\064\146\065\127\066\120\067" +
    "\132\070\115\071\125\072\123\074\147\075\077\076\074" +
    "\077\073\100\076\105\105\106\071\142\057\153\054\001" +
    "\001\000\042\011\055\030\121\050\144\056\122\057\053" +
    "\060\101\061\072\074\145\075\077\076\074\077\073\100" +
    "\076\105\105\106\071\142\057\153\054\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\165\001\001\000\004" +
    "\004\163\001\001\000\004\004\161\001\001\000\004\004" +
    "\157\001\001\000\040\011\055\056\107\057\053\060\101" +
    "\061\072\072\156\074\147\075\077\076\074\077\073\100" +
    "\076\105\105\106\071\142\057\153\054\001\001\000\002" +
    "\001\001\000\040\011\055\056\107\057\053\060\101\061" +
    "\072\072\160\074\147\075\077\076\074\077\073\100\076" +
    "\105\105\106\071\142\057\153\054\001\001\000\002\001" +
    "\001\000\040\011\055\056\107\057\053\060\101\061\072" +
    "\072\162\074\147\075\077\076\074\077\073\100\076\105" +
    "\105\106\071\142\057\153\054\001\001\000\002\001\001" +
    "\000\040\011\055\056\107\057\053\060\101\061\072\072" +
    "\164\074\147\075\077\076\074\077\073\100\076\105\105" +
    "\106\071\142\057\153\054\001\001\000\002\001\001\000" +
    "\040\011\055\056\107\057\053\060\101\061\072\072\166" +
    "\074\147\075\077\076\074\077\073\100\076\105\105\106" +
    "\071\142\057\153\054\001\001\000\002\001\001\000\040" +
    "\011\055\030\171\056\107\057\053\060\101\061\072\074" +
    "\172\075\077\076\074\077\073\100\076\105\105\106\071" +
    "\142\057\153\054\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\054\011\055\056\107\057\053" +
    "\060\101\061\072\064\174\065\127\066\120\067\132\070" +
    "\115\071\125\072\123\074\147\075\077\076\074\077\073" +
    "\100\076\105\105\106\071\142\057\153\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\064\011\055\030\121" +
    "\050\126\051\137\056\122\057\053\060\101\061\072\063" +
    "\200\064\141\065\127\066\120\067\132\070\115\071\125" +
    "\072\123\074\133\075\077\076\074\077\073\100\076\105" +
    "\105\106\071\142\057\153\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\027\207\033\213\001\001\000\002\001\001" +
    "\000\002\001\001\000\054\011\055\056\107\057\053\060" +
    "\101\061\072\064\220\065\127\066\120\067\132\070\115" +
    "\071\125\072\123\074\147\075\077\076\074\077\073\100" +
    "\076\105\105\106\071\142\057\153\054\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\054\011\055\056\107\057\053" +
    "\060\101\061\072\064\224\065\127\066\120\067\132\070" +
    "\115\071\125\072\123\074\147\075\077\076\074\077\073" +
    "\100\076\105\105\106\071\142\057\153\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\022\231\043\233\001\001\000\002\001" +
    "\001\000\012\011\236\012\237\044\235\045\234\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\024\007\056\010\060" +
    "\011\055\025\241\026\045\056\046\057\053\142\057\153" +
    "\054\001\001\000\004\017\242\001\001\000\002\001\001" +
    "\000\004\011\247\001\001\000\024\007\056\010\060\011" +
    "\055\025\245\026\045\056\046\057\053\142\057\153\054" +
    "\001\001\000\004\017\246\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\011\236\012\237" +
    "\045\252\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\161\255\001\001\000\006\023\257\036\260\001\001" +
    "\000\004\162\262\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\037\264\040\263\001\001" +
    "\000\014\011\236\012\237\042\276\045\275\164\273\001" +
    "\001\000\004\163\270\001\001\000\004\165\266\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\041\302\046\301" +
    "\001\001\000\002\001\001\000\004\166\277\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\011\055\056\304\057" +
    "\053\142\057\153\054\001\001\000\002\001\001\000\004" +
    "\047\306\001\001\000\002\001\001\000\044\011\055\030" +
    "\121\050\126\051\313\056\122\057\053\060\101\061\072" +
    "\074\145\075\077\076\074\077\073\100\076\105\105\106" +
    "\071\142\057\153\054\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\037" +
    "\315\040\263\001\001\000\002\001\001\000\002\001\001" +
    "\000\024\007\056\010\060\011\055\025\320\026\045\056" +
    "\046\057\053\142\057\153\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\006\324\001\001\000\002\001" +
    "\001\000\024\007\056\010\060\011\055\025\325\026\045" +
    "\056\046\057\053\142\057\153\054\001\001\000\004\017" +
    "\326\001\001\000\002\001\001\000\002\001\001\000\054" +
    "\011\055\056\107\057\053\060\101\061\072\064\331\065" +
    "\127\066\120\067\132\070\115\071\125\072\123\074\147" +
    "\075\077\076\074\077\073\100\076\105\105\106\071\142" +
    "\057\153\054\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\175\334\001\001\000\010\107\335\110\340\111" +
    "\337\001\001\000\004\004\u0119\001\001\000\002\001\001" +
    "\000\056\011\343\056\374\057\053\105\366\112\372\113" +
    "\355\114\354\115\347\116\351\117\344\123\363\124\356" +
    "\126\361\127\353\130\360\131\365\134\373\135\362\142" +
    "\057\152\357\153\054\160\342\001\001\000\002\001\001" +
    "\000\016\011\055\056\u0159\057\053\132\u0158\142\057\153" +
    "\054\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\011\055\056\u0149\057\053\142\057\153" +
    "\054\001\001\000\004\004\u0147\001\001\000\002\001\001" +
    "\000\054\011\055\056\107\057\053\060\101\061\072\064" +
    "\u0145\065\127\066\120\067\132\070\115\071\125\072\123" +
    "\074\147\075\077\076\074\077\073\100\076\105\105\106" +
    "\071\142\057\153\054\001\001\000\002\001\001\000\056" +
    "\011\055\056\107\057\053\060\101\061\072\064\u011d\065" +
    "\127\066\120\067\132\070\115\071\125\072\123\074\147" +
    "\075\077\076\074\077\073\100\076\105\105\106\071\122" +
    "\u013f\142\057\153\054\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\u0130\001\001\000\002" +
    "\001\001\000\006\005\u0114\121\u0113\001\001\000\004\011" +
    "\u0111\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\011\u0103\001\001\000\002\001\001\000\006\053\u0101\054" +
    "\021\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\054\011\055\056\107\057\053\060\101\061" +
    "\072\064\377\065\127\066\120\067\132\070\115\071\125" +
    "\072\123\074\147\075\077\076\074\077\073\100\076\105" +
    "\105\106\071\142\057\153\054\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\010\u0108\011\055" +
    "\030\u0106\035\u0107\056\u010a\057\053\060\101\061\072\074" +
    "\172\075\077\076\074\077\073\100\076\105\105\106\071" +
    "\142\057\153\054\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\004\u010f\001\001\000\006\027\207\033\u010e" +
    "\001\001\000\044\010\u0108\011\055\030\u0106\035\u010c\056" +
    "\u010a\057\053\060\101\061\072\074\172\075\077\076\074" +
    "\077\073\100\076\105\105\106\071\142\057\153\054\001" +
    "\001\000\006\027\207\033\u010b\001\001\000\002\001\001" +
    "\000\004\004\u010d\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\004\u0115\001" +
    "\001\000\004\120\u011b\001\001\000\004\004\u0117\001\001" +
    "\000\010\107\u0118\110\340\111\337\001\001\000\004\004" +
    "\u0119\001\001\000\006\110\u011a\111\337\001\001\000\002" +
    "\001\001\000\006\005\u0123\121\u0122\001\001\000\056\011" +
    "\055\056\107\057\053\060\101\061\072\064\u011d\065\127" +
    "\066\120\067\132\070\115\071\125\072\123\074\147\075" +
    "\077\076\074\077\073\100\076\105\105\106\071\122\u011e" +
    "\142\057\153\054\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\004\u0120\001\001\000\010\107\u0121\110\340" +
    "\111\337\001\001\000\004\004\u0119\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\u0125\001\001\000\056" +
    "\011\055\056\107\057\053\060\101\061\072\064\u011d\065" +
    "\127\066\120\067\132\070\115\071\125\072\123\074\147" +
    "\075\077\076\074\077\073\100\076\105\105\106\071\122" +
    "\u0126\142\057\153\054\001\001\000\002\001\001\000\004" +
    "\004\u0128\001\001\000\010\107\u0129\110\340\111\337\001" +
    "\001\000\004\004\u0119\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\125\u0131\001\001\000\002" +
    "\001\001\000\004\171\u0133\001\001\000\010\107\u0134\110" +
    "\340\111\337\001\001\000\004\004\u0119\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\170\u0138\001\001\000" +
    "\004\003\u0139\001\001\000\002\001\001\000\004\172\u013b" +
    "\001\001\000\010\107\u013c\110\340\111\337\001\001\000" +
    "\004\004\u0119\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\167\u0141\001\001\000\004\004" +
    "\u0142\001\001\000\010\107\u0143\110\340\111\337\001\001" +
    "\000\004\004\u0119\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\056\011\055\056\107\057\053" +
    "\060\101\061\072\064\u011d\065\127\066\120\067\132\070" +
    "\115\071\125\072\123\074\147\075\077\076\074\077\073" +
    "\100\076\105\105\106\071\122\u0148\142\057\153\054\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\126\u014c\130\u014d\001\001\000\004\004\u0154\001" +
    "\001\000\002\001\001\000\004\173\u014f\001\001\000\010" +
    "\107\u0150\110\340\111\337\001\001\000\004\004\u0119\001" +
    "\001\000\004\011\u0152\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\125\u0155\001\001\000\004\011\u0156\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\133\u015a" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\004" +
    "\u015c\001\001\000\056\011\055\056\107\057\053\060\101" +
    "\061\072\064\u011d\065\127\066\120\067\132\070\115\071" +
    "\125\072\123\074\147\075\077\076\074\077\073\100\076" +
    "\105\105\106\071\122\u015d\142\057\153\054\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\011\u0161\141\u0160" +
    "\142\u0162\151\u0163\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\176\u0165" +
    "\001\001\000\004\003\u0166\001\001\000\002\001\001\000" +
    "\006\143\u0168\144\u016a\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\011\u016d\012\u016f\145" +
    "\u016c\146\u016e\001\001\000\004\174\u017c\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\147" +
    "\u0173\001\001\000\002\001\001\000\002\001\001\000\024" +
    "\007\056\010\060\011\055\025\u0174\026\045\056\046\057" +
    "\053\142\057\153\054\001\001\000\004\017\u0175\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\147\u0178\001" +
    "\001\000\024\007\056\010\060\011\055\025\u0179\026\045" +
    "\056\046\057\053\142\057\153\054\001\001\000\004\017" +
    "\u017a\001\001\000\002\001\001\000\010\011\u016d\012\u016f" +
    "\146\u017e\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    /**Lista donde se guardan los errores encontrados*/
    public ArrayList<String> errores=new ArrayList<String>();
    /**Mtodo para devolver tanto los errores del parser como los  del lexer, si los hay*/
    public ArrayList<String> getErrores(){
		if(getScanner() instanceof Ada95Lexer){
			errores.addAll(((Ada95Lexer)getScanner()).lexical_errors);		
		}
		return errores;

	}
    /**Mtodo que devuelve las advertencias, hasta esta versin, slo el lexer tiene advertencias...*/
    public ArrayList<String> getAdvertencias(){
	ArrayList<String> warnings=new ArrayList<String>();
	if(getScanner() instanceof Ada95Lexer){
		warnings.addAll(((Ada95Lexer)getScanner()).lexical_warnings);		
	}
	return warnings;
		
    }
    boolean EOFReported=false;
    Stack<String> unClosed=new Stack<String>();
    public String getUnclosed(){return unClosed.pop();}
    public void setUnclosed(String faltante,String abierto, int line, int col){
	String addToUnClosed="'"+faltante+"'"+" faltante para el '"+abierto+"' abierto en lnea "+(line+1)+", columna "+(col+1);
	unClosed.push(addToUnClosed);

    }
    public void emptyLastUnclosed(){String tempUnClosed=unClosed.pop();tempUnClosed=null;}
    	
    /**Guardar los errores en un stringBuffer*/
    //StringBuffer errorMessages=new StringBuffer();
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   	
	/*If the EOF was already reported, just return (to avoid that horrible unexpected EOF...)*/
	if(EOFReported)
		return;
        /* Create a StringBuffer called 'm' with the string 'Error' in it. */
        StringBuffer m = new StringBuffer();
        /* Add to the end of the StringBuffer error message created in
           this method the message that was passed into this method. */
	if(message.equalsIgnoreCase("Syntax error")){
		message="Error Sintctico  ";
	}else if(message.equalsIgnoreCase("Couldn't repair and continue parse")){
		message="Error ";
	}	
        m.append(message);
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(": en lnea "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0) {                   
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", columna "+(s.right+1));
		   //ver si se puede sacar el texto:
		   if(getScanner() instanceof Ada95Lexer){
			m.append("; no se esperaba '"+((Ada95Lexer)getScanner()).getCurrentText()+"'");
		   }
		}
	///guardar el error en la variable de errores:
            }else if(s.toString().equals("#0")){
			if(unClosed.empty()){				
				m.append(": final de archivo inesperado");
			}else{
				m.append(": "+getUnclosed());
				EOFReported=true;
			}

		}

        }
   
   
        /* Print the contents of the StringBuffer 'm', which contains
           an error message, out on a line. */
        //System.err.println(m);
	errores.add(m.toString());
	/*Guardar el error en el buffer, mas un salto de lnea:*/
	//	errorMessages.append(m+"\n");
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);

        //System.exit(1);
    }
 /**La funcin que guarda errores para luego ser impresos por el front-end
*@param line, column la lnea y columna del error/
public void push_error(int line, int column){
	errores.add(new String(String.valueOf(line)+"_"+String.valueOf(column)));
	System.out.println(errores);
}*/



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {



/**The current symbol table*/
LinkedSymbolTable currentScope = null; 
/**Variables globales para el control de los subprogramas*/
ArrayList<Type> returns=new ArrayList<Type>();
int branches=0;
/*Variables para la generacin de cdigo intermedio*/
//las instrucciones
ArrayList<Cuadruplo> cuadruplos=new ArrayList<Cuadruplo>();
public static final int MIPS_TEMPS=9;
//los temporales cf: http://en.wikipedia.org/wiki/MIPS_architecture
boolean[] temps=new boolean[MIPS_TEMPS];
int temp_provisorio=0;
/**Para obtener el siguiente temporal libre*/
public String temp_nuevo(){
	return "%t"+String.valueOf(++temp_provisorio);
}
/**La lista de saltos de salida en el loop actual (slo funciona para salidas inmediatas)*/
ListaSalto currentExit=null;
/**Ir imprimiendo el cdigo intermedio al generarlo*/
public boolean DEBUG=false;
/*Para agregar cudruplos a la lista. Slo generar el cudruplo si no hay errores.*/
public void gen(Object op, Object arg1, Object arg2, Object res){
	//si hay errores y no estamos debugueando, ni siquiera molestarse en seguir:
	if(!DEBUG && parser.errores.size()>0)
		return;
	/*castear a string*/
	String o=op.toString();
	String a1=arg1.toString();
	String a2=arg2.toString();
	String r=res.toString();
	//pasar los argumentos a lowercase, para no tener problemas luego con la st.
	a1=a1.toLowerCase();
	a2=a2.toLowerCase();
	Cuadruplo quad=new Cuadruplo(o, a1, a2, r);
	cuadruplos.add(quad);	
	if(DEBUG){
		System.out.println((cuadruplos.size()-1)+"    "+quad.toString());
	}	
}

/**Funcin que devuelve el String que representa a un branch de cdigo intermedio*/
public String getIf(Object operador){
	String o=operador.toString();
	return "if_"+o;
}

/**Convierte una literal booleana en un nmero*/
public Integer getNumeric(Boolean val){
	int rv= (val.booleanValue()) ? 1 : 0;
        return new Integer(rv);
}
/**Devuelve la lista de saltos de un valor booleano*/
public BackPatchResult getBackPatch(Boolean b){
	BackPatchResult rval=new BackPatchResult();
	if(b.booleanValue()){
		rval.verdadera=new ListaSalto(cuadruplos.size());
		return rval;
	}else{
		rval.falsa=new ListaSalto(cuadruplos.size());
		return rval;
	}
}

/**Dada una lista de saltos completa los correspondientes cudruplos con el salto proveido*/
public void completa(ListaSalto completar, Object con){
	if(completar.lista.isEmpty())
		return;
	int value=0;
	String salto=con.toString();
	for(Integer index : completar.lista){
		//por cualquier cosa
		value=index.intValue();
		if(value < cuadruplos.size() && value >=0){
			cuadruplos.get(value).res=salto;
		}else if(DEBUG){
			System.err.println("Se trat de asignar un salto a un cudruplo invlido; "+
			index+ ". Hay "+cuadruplos.size()+"  cudruplos");
		}
	}
}

/**Genera cdigo para la asignacin, recibe un ParserResult que corresponde a la expresin
   si la expresin tiene backpatch, y ste tiene una listaVerdadera o listaFalsa vacas, 
   genera adems el cdigo para completarlas y darles valor
*/
public void generar_asignacion(ParserResult expression, Object result){	
	//esto nunca debera pasar, pero bueno...
		if(expression.backpatch == null){
			gen(":=", expression.value, "", result);
			return;
		}
	//todo depende, en realidad, del tipo de la expression: (ya que todas tienen sus listaV y listaF)
		if(expression.type instanceof BooleanType){
			completa(expression.backpatch.verdadera, cuadruplos.size());
			gen(":=", "1", "", result);
			gen("goto", "", "",cuadruplos.size()+1);
			completa(expression.backpatch.falsa, cuadruplos.size());
			gen(":=", "0", "", result);
		}else{
			gen(":=", expression.value, "", result);
		}
}

 /**Esta funcin chequea que un subprograma que tiene nombre al principio y final tenga exactamente el mismo nombre
   * @param start la palabra del inicio
     @param sline, scolumn el left y right del smbolo start
     @param end la palabra del final
     @param eline, ecolumn el left y right del smbolo end
 */

 public void check_coherence(Object start, int sline, int scolumn, Object end, int eline, int ecolumn){
	 String s=(String)start;
	 String sInfo="inicio: "+s+" ["+String.valueOf(sline+1)+" , "+String.valueOf((scolumn-s.length()))+"]";
	//la funciones pueden no tener el del final:
	 if(end==null){return;}
	 String e=(String)end;
	 String eInfo=" y fin: "+e+" ["+String.valueOf(eline+1)+" , "+String.valueOf(ecolumn+1)+"]";
	 //ver si son lo mismo:
	if(!s.equals(e)){
		//System.err.println("Error sintctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
		parser.errores.add("Error sintctico  : el nombre del subprograma debe coincidir entre "+sInfo+eInfo);
	}
	

 }
/**Mtodo para comprobar errores semnticos de tipo. Los agrega tambin a la lista de errores. Se vale del mtodo equals de las clases
   que heredan de Type.
   @param expected el tipo esperado
   @param found el tipo encontrado
   @param foundLine, foundColumn, etc la lnea y columna donde se encuentra la declaracin.
*/
/*public boolean compare_types(Object expected, Object found, int foundLine, int foundColumn){
	Type etipo=(Type)expected;
	Type ftipo=(Type)found;
	Type e=(etipo instanceof FunctionType)? (((FunctionType)etipo).getRange()) : etipo;
	Type f=(ftipo instanceof FunctionType)? (((FunctionType)ftipo).getRange()) : ftipo;
	if(! e.equals(f)){
		StringBuffer errorMessage=new StringBuffer();
		errorMessage.append("Se esperaba el tipo "+e.toString());
		errorMessage.append(" Y se encontr "+f.toString());
		errorMessage.append(" En lnea "+String.valueOf(foundLine+1)+", columna "+String.valueOf(foundColumn+1));
		parser.errores.add(errorMessage.toString());
		return false;		
	}
	return true;
}*/
/**Mtodo para determinar si un smbolo est o no declarado*/
public AdaSymbol findSymbol(Object id, int line, int column){
	AdaSymbol found;
	found=currentScope.get(id);
	if(found == null){
		parser.errores.add(" No se encuentra el smbolo '"+(String)id+"'. En lnea "+(String.valueOf(line+1))+", columna "+String.valueOf(column+1));
		return null;
	}
	return found;
	
}
/*Agrega un error a los errores del parser*/
public void agregarError(String mensaje, int linea, int columna){
	parser.errores.add(mensaje+". En lnea "+String.valueOf(linea+1)+", columna "+String.valueOf(columna+1));
}

public boolean validateBuiltIn(String method, Object val, int line, int col){
	if(method.equalsIgnoreCase("put") || method.equalsIgnoreCase("get")){
	//the value must be an arraylist of Parser Results:
		if(!(val instanceof ArrayList))
			return false;
	//if it is, cast:
		ArrayList<ParserResult> l=(ArrayList<ParserResult>)val;
	//now, check that it has only one parameter:
		if(l.size()!=1){
			agregarError("La funcin '"+method+"' solamente admite 1 parmetro, "+String.valueOf(l.size())+" suministrados", line, col);
			return false;
		}
	//it has, so, check that the type is valid: it must be one of the primitive types:
		return l.get(0).type.isPrimitive();
		
	}	

	
	//invalid method:
	return false;
}


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= goal EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // constant_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // constant_option ::= CONSTANT 
            {
              Object RESULT =null;
		RESULT=true;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_option",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // goal ::= compilation 
            {
              Object RESULT =null;
		int gleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int gright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object g = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
if(parser.errores.size() == 0){	
	if(DEBUG){
		int i=0;
		for(Cuadruplo c: cuadruplos){
			System.out.println(i+"\t"+c.toString());
			i++;
		}
	}
	//aplanar las tablas de smbolos
	if(currentScope != null){
		FlatSymbolTable tabla=new FlatSymbolTable(currentScope);
		RESULT=new FrontEndResult(cuadruplos, tabla);
	}
}else{
	RESULT=null;
}

              CUP$parser$result = parser.getSymbolFactory().newSymbol("goal",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // placeholder ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("placeholder",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // m ::= 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new Integer(cuadruplos.size()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("m",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // n ::= 
            {
              Object RESULT =null;
		BackPatchResult br= new BackPatchResult(new ListaSalto(cuadruplos.size()));
			gen("goto", " ", "", "");
			RESULT=new ParserResult(br);
		      
              CUP$parser$result = parser.getSymbolFactory().newSymbol("n",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // numeric_type ::= INTEGER 
            {
              Object RESULT =null;
		RESULT=new ParserResult("integer", new IntegerType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // numeric_type ::= FLOAT 
            {
              Object RESULT =null;
		RESULT=new ParserResult("float", new FloatType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("numeric_type",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // primitive_type ::= BOOLEAN 
            {
              Object RESULT =null;
		RESULT=new ParserResult("boolean",new BooleanType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // primitive_type ::= numeric_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=(ParserResult)t;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primitive_type",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // identifier ::= IDENTIFIER 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=i;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // argument_list ::= argument 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		if(a != null){
			 ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.add((ParserResult)a);
			  RESULT=r;
			}
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // argument_list ::= argument_list COMMA argument 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		if(a != null){
			  ArrayList<ParserResult> r=new ArrayList<ParserResult>();
			  r.addAll((ArrayList<ParserResult>)l);
			  r.add((ParserResult)a);
			  RESULT=r;
			 }else{RESULT=l;}			
			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("argument_list",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // argument ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // argument ::= identifier ARROW expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("argument",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // declaration ::= object_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // declaration ::= type_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // declaration ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // declaration ::= subtype_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // declaration ::= number_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // object_declaration ::= identifier COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		ParserResult ps=(ParserResult)s; 
				//if the type is null, there was an error down the tree (and is already reported)
				if (ps.type != null){				
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){			
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					if(!currentScope.put(i, new AdaSymbol(tipo, isConstant)))
						agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
					else //hay inicializacin y todo est bien:
						generar_asignacion(po, i);
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaracin de un objeto constante requiere una expresin de inicializacin", ileft, iright);					        if(!currentScope.put(i, new AdaSymbol(ps.type)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				   	
				}
				}else{//s no es un subtipo de nada:
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);	
				}
					
				}
              CUP$parser$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // object_declaration ::= identifier_list COLON constant_option subtype_indication initialization_option SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				ParserResult ps=(ParserResult)s; 
				if (ps.type != null){
				ArrayList<String> il=(ArrayList<String>)i;
				boolean isConstant=(c != null); 
				if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
				if(o != null){				
					ParserResult po=(ParserResult)o;
					boolean compare=compare_types(ps.type, po.type, oleft, oright);
					//Type tipo=compare ? ps.type : new ErrorType(ps.type);					
					Type tipo=ps.type;
					for(String id:il){
						if(!currentScope.put(id, new AdaSymbol(tipo, isConstant)))
							agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
						else
							generar_asignacion(po, id);
					}	
				}else{//there's no initialization expression:
				   if(isConstant)
					agregarError("La declaracin de un objeto constante requiere una expresin de inicializacin", ileft, iright);	  
				   for(String id:il){
					if(!currentScope.put(id, new AdaSymbol(ps.type)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
				   }	
				}
				}else{
					agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
	
				}
				}
              CUP$parser$result = parser.getSymbolFactory().newSymbol("object_declaration",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // initialization_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // initialization_option ::= ASSIGNMENT expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("initialization_option",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // number_declaration ::= identifier COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		if(o != null){
				  ParserResult po=(ParserResult)o;
			          if(!currentScope.put(i, new AdaSymbol(po.type, true)))
					agregarError("El identificador "+((String)i)+" ya ha sido declarado", ileft, iright);
				  else
					generar_asignacion(po, i);
				  }
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // number_declaration ::= identifier_list COLON CONSTANT ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		if(o != null){
				ParserResult po=(ParserResult)o;ArrayList<String> pi=(ArrayList<String>)i;
				for(String id:pi){
					if(!currentScope.put(id, new AdaSymbol(po.type, true)))
						agregarError("El identificador "+id+" ya ha sido declarado", ileft, iright);
					else
						generar_asignacion(po, id);
				}	
				}  		
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("number_declaration",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // identifier_list ::= identifier COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		ArrayList<String>r=new ArrayList<String>();
				  r.add((String)i); r.add((String)j);
				  RESULT=r;		
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // identifier_list ::= identifier_list COMMA identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int jright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		ArrayList<String> r =new ArrayList<String>();
				  r.addAll((ArrayList<String>)i);r.add((String)j);	
				  RESULT=r;	
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // NT$0 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
gen("record", i.toString(), "", "");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",111, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // type_declaration ::= TYPE identifier discriminant_part_option IS NT$0 type_definition SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
				//viene una tabla de smbolos: porque siempre son records
				LinkedSymbolTable table=(LinkedSymbolTable)t;
				if(!currentScope.put(i, new AdaSymbol(new RecordType(((String)i),table)))){
					agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
				}else{
					table.id=i.toString().toLowerCase();
					table.ancestor=currentScope;
					currentScope.addChild(table);
					gen("initRecord",table.getFlatId(),String.valueOf(table.desplazamiento), "" );					      	      gen("exit", table.getFlatId(), "", "");
				}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // type_declaration ::= incomplete_type_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_declaration",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // discriminant_part_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // discriminant_part_option ::= discriminant_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_part_option",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // type_definition ::= record_type_definition 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		parser.emptyLastUnclosed();RESULT=r;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // subtype_declaration ::= SUBTYPE identifier IS subtype_indication SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					ParserResult ps=(ParserResult)s;
					if(ps.type!= null){
					if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
						Type t=ps.type;
						t.name=(String)i;
						//se pone un nuevo tipo con otro nombre:
						if(!currentScope.put(i, new AdaSymbol(t, true))){
							agregarError("El tipo '"+((String)i)+"' ya ha sido declarado", ileft, iright);
						}
					}
					}else{
						agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
					}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_declaration",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // subtype_indication ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=n;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // subtype_indication ::= subtype_indication_with_constraint 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=c;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // subtype_indication ::= primitive_type 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=t;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // subtype_indication_with_constraint ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // subtype_indication_with_constraint ::= name accuracy_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // subtype_indication_with_constraint ::= numeric_type range_constraint 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT=n;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // subtype_indication_with_constraint ::= FLOAT accuracy_constraint 
            {
              Object RESULT =null;
		RESULT=new ParserResult(new FloatType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subtype_indication_with_constraint",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // range_constraint ::= RANGE range 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("range_constraint",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // range ::= simple_expression DOUBLEDOT simple_expression 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("range",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // accuracy_constraint ::= floating_point_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // accuracy_constraint ::= fixed_point_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("accuracy_constraint",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // floating_point_constraint ::= DIGITS simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("floating_point_constraint",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // range_constraint_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // range_constraint_option ::= range_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("range_constraint_option",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // fixed_point_constraint ::= DELTA simple_expression range_constraint_option 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("fixed_point_constraint",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // discrete_range ::= name range_constraint_option 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // discrete_range ::= numeric_type range_constraint_option 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // discrete_range ::= range 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=r;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("discrete_range",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // NT$1 ::= 
            {
              Object RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
parser.setUnclosed("end record;", "record", rleft,rright );
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",112, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
RESULT=l;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",113, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // record_type_definition ::= RECORD NT$1 component_list NT$2 END RECORD 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type_definition",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // NT$3 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
RESULT=l;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",114, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // component_list ::= component_declaration_list NT$3 variant_part_option 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$4 ::= 
            {
              Object RESULT =null;
RESULT=new LinkedSymbolTable();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",115, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // component_list ::= NULL NT$4 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_list",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // component_declaration_list ::= 
            {
              Object RESULT =null;
		RESULT=new LinkedSymbolTable();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // component_declaration_list ::= component_declaration_list component_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		LinkedSymbolTable t=(LinkedSymbolTable)l;
					  //the components are parserResults: en el valor viene el nombre.
					//c puede ser una lista o un solo elemento:
					if(c != null){	
					  if(!(c instanceof ArrayList)){
					 	 ParserResult p=(ParserResult)c;
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }
					  }else{//s es una lista:
						ArrayList<ParserResult> lc=(ArrayList<ParserResult>)c;
						for(ParserResult p: lc){
						  if(!t.put(p.value, new AdaSymbol(p.type))){
							agregarError("El componente '"+((String)p.value)+
							"' ya ha sido declarado en este registro.", cleft, cright);
						  }//no se pudo meter el id
							
						}//iterar en c
					  }//c es una lista
				
					}//c existe
					//subir la tabla de smbolos:
					RESULT=t;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_declaration_list",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // variant_part_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // variant_part_option ::= variant_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part_option",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // NT$5 ::= 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
RESULT=d;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",116, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // component_declaration ::= discriminant_declaration NT$5 SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // component_declaration ::= error 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_declaration",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // discriminant_part ::= LEFTPAR discriminant_declaration_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_part",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // discriminant_declaration_list ::= discriminant_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // discriminant_declaration_list ::= discriminant_declaration_list SEMICOLON discriminant_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_declaration_list",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // discriminant_declaration ::= identifier COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		//ver si el tipo existe. Si existe, ver si coincide con la inicializacin.
					  //si algo malo pasa, devolver null.
					  ParserResult ps=(ParserResult)s;
					  if(ps.type != null){//si el tipo s fue encontrado:
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)) //si el tipo ES un tipo:
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 if(compare_types(ps.type, po.type, oleft, oright)){
									generar_asignacion(po, i);
								 }
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 RESULT=new ParserResult(i, tipo);
							}else{//no hay inicializacin:
								RESULT=new ParserResult(i, ps.type);
							}
						  else{
							RESULT=new ParserResult(i);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						  }
					  }else{//el tipo no fue encontrado
						RESULT=null;
					  }
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // discriminant_declaration ::= identifier_list COLON subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					  ParserResult ps=(ParserResult)s;
					  ArrayList<String> il=(ArrayList<String>)l;
					  if(ps.type != null){//si el tipo s fue encontrado:
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							if(o != null){//ver si el tipo de o coincide con el de s:
								 ParserResult po=(ParserResult)o;
								 boolean compare=compare_types(ps.type, po.type, oleft, oright);
								 //Type tipo=compare ? ps.type : new ErrorType(ps.type);
								 Type tipo=ps.type;
								 for(String id: il){		
									if(compare){
										generar_asignacion(po, id);
									}				
									r.add(new ParserResult(id, tipo));					
								 }
								 RESULT=r;
							}else{//no hay inicializacin:
								 for(String id: il){						
									r.add(new ParserResult(id, ps.type));					
								 }
								 RESULT=r;
							}
						}else{
							for(String id:il){
								r.add(new ParserResult(id));
							}
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
					  }else{
						RESULT=null;
					  }
						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("discriminant_declaration",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // variant_part ::= CASE name IS variant_list END CASE SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // variant_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // variant_list ::= variant_list WHEN choice_list ARROW component_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // choice ::= simple_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // choice ::= OTHERS 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // choice ::= name range_constraint 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // choice ::= range 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // choice_list ::= choice 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // choice_list ::= choice_list VERTICAL_LINE choice 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("choice_list",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // incomplete_type_declaration ::= TYPE identifier discriminant_part_option SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("incomplete_type_declaration",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // declarative_part ::= declarative_item_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_part",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // declarative_item_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // declarative_item_list ::= declarative_item_list declarative_item 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_item_list",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // declarative_item ::= declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // declarative_item ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // declarative_item ::= error SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declarative_item",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // name ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		//buscar el nombre en la tabla de smbolos:
					  AdaSymbol f=findSymbol(i, ileft, iright);
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						RESULT=new ParserResult(i);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // name ::= selected_component 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=s;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // name ::= function_call 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=f;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // name ::= operator_symbol 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		//buscar el nombre en la tabla de smbolos:					  
					  ParserResult pi=(ParserResult)i;
					  //AdaSymbol f=findSymbol(pi.value, ileft, iright);
					  /*Si no lo encuentra, asumamos que es un string normal...*/
					  AdaSymbol f=currentScope.get(pi.value);					  
					  if(f!= null)
						RESULT=new ParserResult(i, f.type);						 
					  else
						//RESULT=new ParserResult(i);
						RESULT=pi;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("name",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // selected_component ::= name POINT identifier 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					//the selected component query:
						ParserResult namen=(ParserResult)n;
						String valex=((String)namen.value)+"."+((String)i);
						Type t=null;
					//query for it in the current scope:
						AdaSymbol f=currentScope.get(valex);		
						if (f !=null)//found:
							t=f.type;
						else
							parser.errores.add("No se puede encontrar el componente '"+((String)i)+
							"' para el prefijo '"+((String)namen.value)+ "'. En lnea "+String.valueOf(nleft+1)+
							", columna "+String.valueOf(nright+1));
						RESULT=new ParserResult(valex, t);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // selected_component ::= name POINT ALL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
					AdaSymbol f=findSymbol(n, nleft, nright);
					if(f != null)
						RESULT=new ParserResult(n, f.type);
					else
						RESULT=new ParserResult(n);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // selected_component ::= name POINT operator_symbol 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("selected_component",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // literal ::= INTEGER_LITERAL 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Integer i = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(i, new IntegerType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // literal ::= FLOATING_POINT_LITERAL 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Float f = (Float)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT= new ParserResult(f, new FloatType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // literal ::= CHARACTER_LITERAL 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT= new ParserResult(c, new StringType(1));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // literal ::= BOOLEAN_LITERAL 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT= new ParserResult(getNumeric(b), new BooleanType(), getBackPatch(b));
					  gen("goto", " ", "", "");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // literal ::= NULL 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT= new ParserResult(n);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("literal",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // aggregate ::= LEFTPAR component_association_list RIGHTPAR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // aggregate ::= LEFTPAR choice_list ARROW expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("aggregate",47, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // component_association_list ::= component_association COMMA component_association 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // component_association_list ::= component_association_list COMMA component_association 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_association_list",48, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // component_association ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // component_association ::= choice_list ARROW expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_association",49, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // expression ::= relation 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // expression ::= and_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // expression ::= or_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // expression ::= xor_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // expression ::= andthen_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // expression ::= orelse_expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // and_expression ::= relation AND m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("and_expression",51, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // or_expression ::= relation OR m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("or_expression",52, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // xor_expression ::= relation XOR relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("xor_expression",53, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // andthen_expression ::= relation AND_THEN m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("andthen_expression",54, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // orelse_expression ::= relation OR_ELSE m relation 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("orelse_expression",55, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // relation ::= simple_expression 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relation",56, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // membership_operator ::= IN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // membership_operator ::= NOT IN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("membership_operator",57, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // simple_expression ::= term_list 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // term_list ::= term 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("term_list",59, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // term ::= factor 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",60, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // factor ::= primary 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // primary ::= literal 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=l;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // primary ::= aggregate 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // primary ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		ParserResult nr=(ParserResult)n;
					  /***/
					  if(!nr.clean){						
						RESULT=new ParserResult(nr.place, nr.type);
					  }else{
					 	RESULT=n;
					 }
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // primary ::= allocator 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // primary ::= qualified_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // primary ::= LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",62, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // relational_operator ::= EQUAL 
            {
              Object RESULT =null;
		RESULT= new ParserResult("==");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // relational_operator ::= INEQUALITY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("/=");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // relational_operator ::= LT 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // relational_operator ::= GT 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // relational_operator ::= GTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult(">=");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // relational_operator ::= LTEQ 
            {
              Object RESULT =null;
		RESULT= new ParserResult("<=");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relational_operator",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // adding_operator ::= PLUS 
            {
              Object RESULT =null;
		RESULT=new ParserResult("add");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // adding_operator ::= MINUS 
            {
              Object RESULT =null;
		RESULT= new ParserResult("sub");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // adding_operator ::= CONCATENATE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("&");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("adding_operator",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // unary_operator ::= PLUS 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult("+", new IntegerType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // unary_operator ::= MINUS 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult("neg", new IntegerType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // unary_operator ::= NOT 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult("not", new BooleanType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // unary_operator ::= ABS 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult("abs", new IntegerType());
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unary_operator",65, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // multiplying_operator ::= MULTIPLY 
            {
              Object RESULT =null;
		RESULT= new ParserResult("mul");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // multiplying_operator ::= DIVIDE 
            {
              Object RESULT =null;
		RESULT= new ParserResult("div");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // multiplying_operator ::= MOD 
            {
              Object RESULT =null;
		RESULT= new ParserResult("mod");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // multiplying_operator ::= REM 
            {
              Object RESULT =null;
		RESULT= new ParserResult("rem");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("multiplying_operator",66, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // qualified_expression ::= name TICK LEFTPAR expression RIGHTPAR 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // qualified_expression ::= name TICK aggregate 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("qualified_expression",67, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // allocator ::= NEW name 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("allocator",68, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // sequence_of_statements ::= statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=s;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // sequence_of_statements ::= sequence_of_statements m statement 
            {
              Object RESULT =null;
		int qleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int qright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object q = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						ParserResult qr=(ParserResult)q;
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;
						completa(qr.backpatch.siguiente, mr.value);
						RESULT=new ParserResult(
							new BackPatchResult(sr.backpatch.siguiente)
						);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sequence_of_statements",69, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // statement ::= label_list simple_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=s;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // statement ::= label_list compound_statement 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=c;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // statement ::= error 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",70, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // label_list ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // label_list ::= label_list label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",71, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // simple_statement ::= null_statement 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // simple_statement ::= assignment_statement 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // simple_statement ::= exit_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // simple_statement ::= return_statement 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					if(e != null){
						ParserResult pe=(ParserResult)e;
						returns.add(pe.type);
					}else{
						returns.add(new ErrorType());
					}
					RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // simple_statement ::= goto_statement 
            {
              Object RESULT =null;
		int gleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int gright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object g = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // simple_statement ::= procedure_call 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
					  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // simple_statement ::= code_statement 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_statement",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // compound_statement ::= if_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		parser.emptyLastUnclosed(); RESULT=s;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // compound_statement ::= loop_statement 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		parser.emptyLastUnclosed();
						  RESULT=s;
						  //completar el currentExit con la siguiente sentencia:
						  if(currentExit != null){
							completa(currentExit, cuadruplos.size());
							currentExit=null;
						  }
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // compound_statement ::= block 
            {
              Object RESULT =null;
		parser.emptyLastUnclosed();
              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_statement",73, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // label ::= LEFTLABEL identifier RIGHTLABEL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label",74, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // null_statement ::= NULL SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("null_statement",75, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // assignment_statement ::= name ASSIGNMENT expression SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment_statement",76, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // NT$6 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
parser.setUnclosed("end if;", "if", ileft, iright);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // if_header ::= IF condition THEN NT$6 m sequence_of_statements 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 branches++;
					 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Una condicin debe ser de un tipo booleano y se encontr "+pc.type.toString(),
							 cleft, cright);
							RESULT=null;
						}else{
							ParserResult pm=(ParserResult)m;
							ParserResult ps=(ParserResult)s;
							RESULT=new ParserResult(pm.value,
										 new BackPatchResult(ps.backpatch.siguiente,
		 	       										 pc.backpatch.verdadera,
													 pc.backpatch.falsa));
						}
					}
              CUP$parser$result = parser.getSymbolFactory().newSymbol("if_header",81, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // if_statement ::= if_header else_option END IF SEMICOLON 
            {
              Object RESULT =null;
		int headerleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int headerright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object header = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object els = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
					if(header != null){
						ParserResult pc=(ParserResult)header;
						ParserResult RetVal=new ParserResult();
						completa(pc.backpatch.verdadera, pc.value);
						RetVal.backpatch.siguiente=ListaSalto.fusiona(pc.backpatch.siguiente, pc.backpatch.falsa);
						if(els != null){
							ParserResult pelse=(ParserResult)els;
							completa(pc.backpatch.falsa, pelse.value);
							RetVal.backpatch.siguiente=ListaSalto.fusiona(pc.backpatch.siguiente,
									           pelse.backpatch.siguiente);
						}
						RESULT=RetVal;
					 }else{
						RESULT=new ParserResult(new BackPatchResult());
					 }
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("if_statement",77, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // if_statement ::= if_header n m elsif_list else_option END IF SEMICOLON 
            {
              Object RESULT =null;
		int headerleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int headerright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object header = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object els = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		
					 if(header != null){ 
							ParserResult pc=(ParserResult)header;
							ParserResult pm2=(ParserResult)mdos;
							ParserResult pn=(ParserResult)n;
							ParserResult pelsif=(ParserResult)elsif;
							ParserResult pelse=(ParserResult)els;
							BackPatchResult siguiente=new BackPatchResult();
							completa(pc.backpatch.verdadera, pc.value);
							completa(pc.backpatch.falsa, pm2.value);
							siguiente.siguiente=ListaSalto.fusiona(
											ListaSalto.fusiona(pc.backpatch.siguiente,pn.backpatch.siguiente),
											pelsif.backpatch.siguiente
										);	
							if(pelse != null){
								completa(pelsif.backpatch.falsa, pelse.value);
								siguiente.siguiente=ListaSalto.fusiona(siguiente.siguiente, pelse.backpatch.siguiente);
							}else{
								siguiente.siguiente=ListaSalto.fusiona(siguiente.siguiente, pelsif.backpatch.falsa);
							}
							RESULT=new ParserResult(siguiente);
						}else{
							RESULT=new ParserResult(new BackPatchResult());
						}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("if_statement",77, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // elsif_list ::= ELSIF condition THEN m sequence_of_statements 
            {
              Object RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						branches++;
						//comprobacin:
						if(c != null){
							ParserResult pc=(ParserResult)c;
							ParserResult pm=(ParserResult)m;
							ParserResult ps=(ParserResult)s;
							if(!(pc.type instanceof BooleanType)){
								agregarError("Una condicin debe ser de un tipo booleano y se encontr "+pc.type.toString(),
							        cleft, cright);
							}else{
						//backpatching:
							completa(pc.backpatch.verdadera, pm.value);			
							RESULT=new ParserResult(
							 new BackPatchResult(
								ps.backpatch.siguiente,
								new ListaSalto(),
								pc.backpatch.falsa
							 )
							);
							}
						}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // elsif_list ::= elsif_list n ELSIF m condition THEN m sequence_of_statements 
            {
              Object RESULT =null;
		int elsifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int elsifright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object elsif = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int munoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int munoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object muno = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mdosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mdosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object mdos = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 branches++;
					  if(c != null){
						ParserResult pc=(ParserResult)c;
						ParserResult ps=(ParserResult)s;					
						ParserResult pn=(ParserResult)n;
						ParserResult pm1=(ParserResult)muno;
						ParserResult pm2=(ParserResult)mdos;
						ParserResult pelsif=(ParserResult)elsif;

						if(!(pc.type instanceof BooleanType)){
							agregarError("Una condicin debe ser de un tipo booleano y se encontr "+pc.type.toString(),
						        cleft, cright);
						}else{
							completa(pc.backpatch.verdadera, pm2.value);
							completa(pelsif.backpatch.falsa, pm1.value);
							RESULT=new ParserResult(
								new BackPatchResult(
									ListaSalto.fusiona(pn.backpatch.siguiente,
										ListaSalto.fusiona(ps.backpatch.siguiente, pelsif.backpatch.siguiente)
									),
									new ListaSalto(),
									pc.backpatch.falsa
								)
							);
						}
					 }
					
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("elsif_list",78, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // else_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // else_option ::= n ELSE m sequence_of_statements 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		ParserResult ps=(ParserResult)s;
				  ParserResult mr=(ParserResult)m;
				  ParserResult nr=(ParserResult)n;
				  ps.backpatch.siguiente=ListaSalto.fusiona(ps.backpatch.siguiente, nr.backpatch.siguiente);
				  RESULT=new ParserResult(mr.value, ps.backpatch);
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("else_option",79, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // condition ::= expression 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=e;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("condition",80, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // NT$7 ::= 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

					 //se asume que si la iteration_clause existe, se cre una st para sta
					 if(o != null && (((ParserResult)o).value instanceof ArrayList))
						currentScope=currentScope.getAncestor(); 
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // loop_statement ::= iteration_clause_option m basic_loop SEMICOLON NT$7 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		/*la iteration clause ya trae las cosas de la condicin Y el marcador antes de sta*/
						ParserResult mr=(ParserResult)m;
						ParserResult sr=(ParserResult)s;
						ListaSalto siguiente;
						if(o != null){
							ParserResult iteration=(ParserResult)o;
							completa(iteration.backpatch.verdadera, mr.value);						
							if(iteration.value instanceof ArrayList){
								ArrayList<Object> post=(ArrayList)iteration.value;
								completa(sr.backpatch.siguiente, cuadruplos.size());
								Cuadruplo step=(Cuadruplo)post.get(1);
								gen(step.operador, step.arg1, step.arg2, step.res);
								//genera un goto adonde est la condicin:
								gen("goto", "", "", post.get(0));
							}else{//no es una lista, si no un simple m
								completa(sr.backpatch.siguiente, iteration.value);	
								gen("goto","", "", iteration.value);
							}
							/*Completar la sequence_of_staments que podra traer las listas de los exit_staments
							  Verdadera: si se cumple ser la siguiente (porque sale)
							  Falsa: completarla con la condicin */
							//completa(sr.backpatch.falsa, iteration.value);
							//siguiente=ListaSalto.fusiona(iteration.backpatch.falsa, sr.backpatch.verdadera);
							siguiente=iteration.backpatch.falsa;
						}else{//es un loop normal, sin iteracin.
							completa(sr.backpatch.siguiente, mr.value);
							gen("goto", "", "", mr.value);
							//siguiente=sr.backpatch.verdadera;
							siguiente=new ListaSalto();
						}
						RESULT=new ParserResult(
							new BackPatchResult(siguiente)
						);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // loop_statement ::= identifier COLON iteration_clause_option m basic_loop identifier SEMICOLON 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int jleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int jright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object j = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
					String si=(String)i; 
					String sj=(String)j;
					if(!si.equalsIgnoreCase(sj))
						agregarError("Se esperaba 'end loop "+si+"' y se encontr 'end loop "+sj+"'", jleft, jright);
					ParserResult mr=(ParserResult)m;
					ParserResult sr=(ParserResult)s;						
					if(o != null && (((ParserResult)o).value instanceof ArrayList)){
						currentScope=currentScope.getAncestor(); 
					  
					/*la iteration clause ya trae las cosas de la condicin Y el marcador antes de sta*/
						ParserResult iteration=(ParserResult)o;
						completa(iteration.backpatch.verdadera, mr.value);
						/*Aqu hay una disyuntiva, o viene una lista o no, si viene
						una, es porque es un for y hay que generarlo*/
						if(iteration.value instanceof ArrayList){
							ArrayList<Object> post=(ArrayList)iteration.value;
							completa(sr.backpatch.siguiente, cuadruplos.size());
							Cuadruplo step=(Cuadruplo)post.get(1);
							gen(step.operador, step.arg1, step.arg2, step.res);
							//genera un goto adonde est la condicin:
							gen("goto", "", "", post.get(0));
						}else{//no es una lista, si no un simple m
							completa(sr.backpatch.siguiente, iteration.value);	
							gen("goto", "", "", iteration.value);
						}
						//TODO: cambiar esto para revisar que el value de la e_stmnt sea una etiqueta de este loop.
						//completa(sr.backpatch.falsa, iteration.value);
						RESULT=new ParserResult(
							new BackPatchResult(iteration.backpatch.falsa)
						);				
					}else{
						completa(sr.backpatch.siguiente, mr.value);
						gen("goto", "", "", mr.value);
						//siguiente=sr.backpatch.verdadera;
						RESULT=new ParserResult(new BackPatchResult(new ListaSalto()));
						
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("loop_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // NT$8 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
parser.setUnclosed("end loop;", "loop",lleft,lright);
					  currentExit=null;
					 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // basic_loop ::= LOOP NT$8 sequence_of_statements END LOOP 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		RESULT=s;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("basic_loop",83, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // iteration_clause_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // iteration_clause_option ::= FOR identifier IN discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					LinkedSymbolTable scope=new LinkedSymbolTable(currentScope); 
					currentScope.addChild(scope);
					currentScope=scope;
					//ver si viene algo en el rango:
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);					
					}
					/*
					//avisar si el rango es nulo:
					if(r ==  null)
						agregarError("Advertencia: El rango del ciclo es nulo y no se ejecutar", rleft, rright);
					*/
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//ac podramos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", initial, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generar las instrucciones:
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(new Integer(cuadruplos.size()));
						gen("if_<", i, fin, "");
						gen("goto", " ", "", "");
						ParserResult mr=(ParserResult)m;
						//post.add(mr.value);
						post.add(new Cuadruplo("add", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
						
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // iteration_clause_option ::= FOR identifier IN REVERSE discrete_range m 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					LinkedSymbolTable scope=new LinkedSymbolTable(currentScope); 
					currentScope.addChild(scope);
					currentScope=scope;
					Type tipo=(r != null) ? ((ParserResult)r).type : new IntegerType();
					if(!currentScope.put(i, new AdaSymbol(tipo, true))){
						agregarError("'"+((String)i)+"' ya ha sido declarado.", ileft, iright);
					}
					//generar la condicin:
					if(r != null){
						ParserResult range=(ParserResult)r;
						Object initial = ((ArrayList<Object>)range.value).get(0);
						Object fin     = ((ArrayList<Object>)range.value).get(1);
						//ac podramos avisar que el rango es nulo
						// identifier := range_initial
						gen(":=", fin, "", i);	
						//las listas verdadera y falsa:
						BackPatchResult b_res=new BackPatchResult(new ListaSalto(cuadruplos.size()),
                                                                                          new ListaSalto(cuadruplos.size()+1));
						//generarlas instrucciones:
						ArrayList<Object> post=new ArrayList<Object>(2);
						post.add(new Integer(cuadruplos.size()));
						gen("if_>=", i, initial, "");
						gen("goto", " ", "", "");
						ParserResult mr=(ParserResult)m;
						post.add(new Cuadruplo("sub", i.toString(), "1", i.toString()));
						RESULT=new ParserResult(post, b_res);
					}	
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // iteration_clause_option ::= WHILE m condition 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Se esperaba un tipo booleano y se encontr"+pc.type.toString(), cleft, cright);
						}else{
							//subir la lista verdadera de la condicin para que la llene el loop y el valor
							// de m para completar lo de las sentencias y generar el goto
							ParserResult res=new ParserResult();
							ParserResult mr=(ParserResult)m;
							res.value=mr.value;
							res.backpatch.falsa=pc.backpatch.falsa;
							res.backpatch.verdadera=pc.backpatch.verdadera;
							RESULT=res;
						}
					 }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_clause_option",84, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // NT$9 ::= 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
parser.setUnclosed("end;", "begin del bloque",bleft, bright);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // block ::= declare_part_option BEGIN NT$9 sequence_of_statements END SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",85, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // NT$10 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
parser.setUnclosed((" end "+((String)i)+ ";"), ("begin del bloque "+((String)i)),ileft, iright);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$10",121, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // block ::= identifier COLON declare_part_option BEGIN NT$10 sequence_of_statements END identifier SEMICOLON 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",85, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // declare_part_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declare_part_option",86, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // declare_part_option ::= DECLARE declarative_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("declare_part_option",86, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // exit_statement ::= EXIT name_option when_option SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int wleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		if(w != null){
						  ParserResult wr=(ParserResult)w;
						  completa(wr.backpatch.falsa, cuadruplos.size());
						  if(currentExit != null){
							currentExit=ListaSalto.fusiona(currentExit, wr.backpatch.verdadera);
						  }else{
							currentExit=wr.backpatch.verdadera;
						  }
						  if(n != null){
							  ParserResult nr=(ParserResult)n;		
							  RESULT=new ParserResult(nr.value, wr.type, wr.backpatch);
						  }else{
							  RESULT=new ParserResult(wr.type, wr.backpatch);
						  }
					  }else{//there is no condition, but a goto must be generated:
					  ListaSalto verdadero=new ListaSalto(cuadruplos.size());
					  BackPatchResult bpr=new BackPatchResult(verdadero, new ListaSalto()); 
					  gen("goto", "", "", " ");
      						if(n != null){
							ParserResult nr=(ParserResult)n;		
							RESULT=new ParserResult(nr.value, bpr); 
						}else{
							RESULT=new ParserResult(bpr);
						}
					  if(currentExit != null){
						currentExit=ListaSalto.fusiona(currentExit, verdadero);
					  }else{
						currentExit=verdadero;
					  }
					  }
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exit_statement",87, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // name_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("name_option",88, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // name_option ::= name 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=n;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("name_option",88, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // when_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("when_option",89, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // when_option ::= WHEN m condition 
            {
              Object RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object c = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(c != null){
						ParserResult pc=(ParserResult)c;
						if(!(pc.type instanceof BooleanType)){
							agregarError("Se esperaba un tipo booleano y se encontr"+pc.type.toString(), cleft, cright);
						}else{
							ParserResult res=new ParserResult();
							ParserResult mr=(ParserResult)m;
							res.value=mr.value;
							res.backpatch.falsa=pc.backpatch.falsa;
							res.backpatch.verdadera=pc.backpatch.verdadera;
							RESULT=res;

						}
					 }
              CUP$parser$result = parser.getSymbolFactory().newSymbol("when_option",89, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // return_statement ::= RETURN SEMICOLON 
            {
              Object RESULT =null;
		
						gen("return", "", "", "");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_statement",90, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // return_statement ::= RETURN expression SEMICOLON 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						ParserResult pe=(ParserResult)e;
						gen("return", pe.value, "", "");
						//gen("goto", "", "", "exit_"+currentScope.id);
						RESULT=e;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_statement",90, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // goto_statement ::= GOTO name SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("goto_statement",91, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // subprogram_declaration ::= subprogram_specification SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subprogram_declaration",92, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // subprogram_specification ::= PROCEDURE identifier formal_part_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subprogram_specification",93, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // subprogram_specification_is ::= PROCEDURE identifier IS 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subprogram_specification_is",94, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // designator ::= identifier 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=i;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator",95, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // designator ::= operator_symbol 
            {
              Object RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=o;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator",95, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // operator_symbol ::= STRING_LITERAL 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=new ParserResult(String.format("\"%s\"", s),
					  new StringType(((String)s).length()));
              CUP$parser$result = parser.getSymbolFactory().newSymbol("operator_symbol",96, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // NT$11 ::= 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
RESULT=l;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$11",122, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // formal_part ::= LEFTPAR parameter_declaration_list NT$11 RIGHTPAR 
            {
              Object RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_part",97, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // formal_part_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_part_option",98, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // formal_part_option ::= formal_part 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=f;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_part_option",98, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // parameter_declaration_list ::= parameter_declaration 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					if(d != null){
						ArrayList<ParserResult> r=new ArrayList<ParserResult>();
					if (!(d instanceof ArrayList)){
						//asumimos que, si no es una lista, es un parser result
						r.add((ParserResult)d);
						RESULT=r;
					}else{
						r.addAll((ArrayList<ParserResult>)d);
						RESULT=r;
					}
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",99, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // parameter_declaration_list ::= parameter_declaration_list SEMICOLON parameter_declaration 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					if(l != null){
						ArrayList<ParserResult> ll=(ArrayList<ParserResult>)l;
						//puede venir un solo elemento o una lista:
						if(d != null){
							if(!(d instanceof ArrayList)){
								ll.add((ParserResult)d);
							}else{
								ll.addAll((ArrayList<ParserResult>)d);
							}
						}
						RESULT=ll;
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_declaration_list",99, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // parameter_declaration ::= identifier COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					ParserResult ps=(ParserResult)s;
					String mode=(String)m;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre=(mode.equalsIgnoreCase("in")) ? ((String)i)+"$constant" : (String)i;
							if(o != null){
								ParserResult po=(ParserResult)o;
								if(mode.equalsIgnoreCase("in")){
									if(compare_types(ps.type, po.type, oleft, oright)){
										//todo est bien, generar el cdigo
										generar_asignacion(po, i);
									}
								}else{//solo los in pueden estar inicializados:
									agregarError("El parmetro '"+i.toString()+"' no es de tipo 'in'"+
									", no puede ser inicializado", oleft, oright);
								}
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								ParserResult r=new ParserResult(nombre, tipo);
								RESULT=r;
							}else{//there's no initialization expression:
								RESULT=new ParserResult(nombre, ps.type);
							}
						}else{
							RESULT=new ParserResult(i);
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);							     }
                	                }else{
						RESULT=null;
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_declaration",100, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // parameter_declaration ::= identifier_list COLON mode subtype_indication initialization_option 
            {
              Object RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Object l = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object m = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
					
					ParserResult ps=(ParserResult)s;
                                	//if the type is null, there was an error down the tree (and is already reported)
	                                if (ps.type != null){
					ArrayList<String> il=(ArrayList<String>)l;
					ArrayList<ParserResult> r=new ArrayList<ParserResult>();
						if(((String)ps.value).equalsIgnoreCase(ps.type.name)){
							String nombre="";
							String mode=(String)m;
							if(o != null){
								ParserResult po=(ParserResult)o;
								boolean compare;
								if(!mode.equalsIgnoreCase("in")){
									agregarError("Los parmetros '"+il.toString()+"' no son de tipo 'in'"+
									", no pueden ser inicializados", oleft, oright);
									compare=false;	
								}else{
									compare=compare_types(ps.type, po.type, oleft, oright);
								}
								//Type tipo=compare ? ps.type : new ErrorType(ps.type);
								Type tipo=ps.type;
								for(String id :il){									
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									if(compare){
										generar_asignacion(po, id);
									}
									r.add(new ParserResult(nombre, tipo));
								}
								RESULT=r;
							}else{//there's no initialization expression:
								for(String id: il){
									nombre=(mode.equalsIgnoreCase("in")) ? id+"$constant" : id;
									r.add(new ParserResult(nombre, ps.type));
								}
								RESULT=r;
							}
						}else{
							for(String id: il)
								r.add(new ParserResult(id));
							RESULT=r;
							agregarError("'"+((String)ps.value)+"' no ha sido declarado como subtipo", sleft, sright);
						}
                	                }else{
						RESULT=null;
					}
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parameter_declaration",100, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // mode ::= 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // mode ::= IN 
            {
              Object RESULT =null;
		RESULT="IN";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // mode ::= OUT 
            {
              Object RESULT =null;
		RESULT="OUT";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // mode ::= IN OUT 
            {
              Object RESULT =null;
		RESULT="INOUT";
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mode",101, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // NT$12 ::= 
            {
              Object RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					parser.setUnclosed((" end "+((String)designator)+";"), "begin",bleft, bright);
					//crear el cdigo para inicializar la funcin
					gen("initFunction", currentScope.getFlatId(),
					 String.valueOf(currentScope.desplazamiento), "");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$12",123, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // NT$13 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

					  if(s != null){
						if(s instanceof ParserResult){
							ParserResult ps=(ParserResult)s;
							for(Type r : returns){
								//si es errortype, ya fue reportado un error
								if(!(r instanceof ErrorType))
									compare_types(ps.type,r,sleft, sright);
							}

							//se asume que slo las funciones tienen branches
							if (returns.size() < branches)
								agregarError("Sentencia de retorno faltante para el subprograma '"+((String)ps.value)+"'"
								, sleft, sright);
						}else{//si no es un ParserResult es un procedure:
							if(returns.size()>0)	
								agregarError("Un procedimiento no puede retornar un valor"+
								" (En el procedimiento '"+((String)s)+"') ", sleft, sright);
						}
					  }
					  //completar la sequence of statements: as todas tienen un salto
					  ParserResult tr=(ParserResult)t;
					  completa(tr.backpatch.siguiente, cuadruplos.size());
					//generar la salida:
					Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					String id=designator.toString();
					if(currentScope.getAncestor() == null)
						gen("glblExit", currentScope.getFlatId(), "", "");
					else
						gen("exit",currentScope.getFlatId(), "", "");
					  //resetear las cosas: el main no debera desaparecer!
					if(currentScope.getAncestor() != null)
						  currentScope=currentScope.getAncestor();
					  returns=new ArrayList<Type>();
					  branches=0;
				  	 //Revisar que no venga un exit_statement
					  if(currentExit != null )	
						  agregarError("No puede salir de un subprograma con una sentencia de salida", sleft, sright);
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$13",124, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // subprogram_body ::= subprogram_specification_is declarative_part BEGIN NT$12 sequence_of_statements END designator_option SEMICOLON NT$13 placeholder 
            {
              Object RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-9)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		Object designator=(s instanceof ParserResult) ? ((ParserResult)s).value : s;
					check_coherence(designator,sleft, sright, e, eleft, eright);
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subprogram_body",102, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-9)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // designator_option ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_option",103, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // designator_option ::= designator 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT=d;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("designator_option",103, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // procedure_call ::= name SEMICOLON 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_call",104, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // function_call ::= name LEFTPAR RIGHTPAR 
            {
              Object RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_call",105, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // actual_parameter_part ::= LEFTPAR argument_list RIGHTPAR 
            {
              Object RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT=a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_part",106, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // compilation ::= compilation_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation",107, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // compilation_list ::= compilation_unit 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // compilation_list ::= compilation_list compilation_unit 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // compilation_list ::= error 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_list",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // compilation_unit ::= subprogram_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_unit",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // compilation_unit ::= subprogram_body 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compilation_unit",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // code_statement ::= qualified_expression SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("code_statement",110, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
